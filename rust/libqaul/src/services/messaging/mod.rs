// Copyright (c) 2021 Open Community Project Association https://ocpa.ch
// This software is published under the AGPLv3 license.

//! # Qaul Messaging Service
//!
//! The messaging service is used for sending, receiving and
//! relay chat messages.

use libp2p::PeerId;
use prost::Message;
use serde::{Deserialize, Serialize};
use sled_extensions::{bincode::Tree, DbExt};
use state::Storage;
use std::collections::{BTreeMap, VecDeque};
use std::sync::RwLock;

mod process;

use super::crypto::Crypto;
use crate::connections::ConnectionModule;
use crate::node::user_accounts::{UserAccount, UserAccounts};
use crate::router::table::RoutingTable;
use crate::storage::database::DataBase;
use crate::utilities::timestamp::{self, Timestamp};
use process::MessagingProcess;
use qaul_messaging::QaulMessagingReceived;

/// Import protobuf message definition generated by
/// the rust module prost-build.
pub mod proto {
    include!("qaul.net.messaging.rs");
}

/// mutable state of messages id for generate uniq id
pub static MESSAGEIDS: Storage<RwLock<MessageIds>> = Storage::new();

/// MessagId Structure
pub struct MessageId {
    timestamp: u64,
    last_index: u32,
}

/// MessageIds structure
pub struct MessageIds {
    /// sender => mesage id
    pub ids: BTreeMap<Vec<u8>, MessageId>,
}

/// mutable state of messages, scheduled for sending
pub static MESSAGING: Storage<RwLock<Messaging>> = Storage::new();

/// mutable state of failed messages, scheduled for sending
pub static FAILEDMESSAGING: Storage<RwLock<FailedMessaging>> = Storage::new();

/// Messaging Scheduling Structure
pub struct ScheduledMessage {
    receiver: PeerId,
    container: proto::Container,
}

/// mutable state of messages, scheduled for sending
pub static UNCONFIRMED: Storage<RwLock<UnConfirmedMessages>> = Storage::new();
#[derive(serde::Serialize, serde::Deserialize, Clone)]
pub struct UnConfirmedMessage {
    pub receiver_id: Vec<u8>,
    pub message_id: Vec<u8>,
    pub container: Vec<u8>,
    pub last_sent: u64,
    pub retry: u32,
}
pub struct UnConfirmedMessages {
    /// signature => UnConfirmedMessage
    pub unconfirmed: Tree<UnConfirmedMessage>,
}

/// Qaul Messaging Structure
pub struct Messaging {
    /// ring buffer of messages scheduled for sending
    pub to_send: VecDeque<ScheduledMessage>,
}

/// Qaul Failed Message Structure
#[derive(Serialize, Deserialize, Clone)]
pub struct FailedMessage {
    pub user_id: Vec<u8>,
    pub conversation_id: Vec<u8>,
    pub created_at: u64,
    pub last_try: u64,
    pub try_count: u32,
    pub message: String,
}

/// Qaul Failed Messaging Structure
pub struct FailedMessaging {
    pub tree: Tree<FailedMessage>,
}

impl Messaging {
    /// Initialize messaging and create the ring buffer.
    pub fn init() {
        let message_ids = MessageIds {
            ids: BTreeMap::new(),
        };
        MESSAGEIDS.set(RwLock::new(message_ids));

        let messaging = Messaging {
            to_send: VecDeque::new(),
        };
        MESSAGING.set(RwLock::new(messaging));

        let db = DataBase::get_node_db();
        let tree: Tree<FailedMessage> = db.open_bincode_tree("failed_messages").unwrap();
        let failed_messaging = FailedMessaging { tree: tree };
        FAILEDMESSAGING.set(RwLock::new(failed_messaging));

        // open trees
        let unconfirmed: Tree<UnConfirmedMessage> = db.open_bincode_tree("unconfirmed").unwrap();
        let unconfirmed_messages = UnConfirmedMessages { unconfirmed };
        UNCONFIRMED.set(RwLock::new(unconfirmed_messages));
    }

    pub fn generate_message_id(sender_id: &PeerId) -> Vec<u8> {
        let timestamp = timestamp::Timestamp::get_timestamp();
        // determine index
        let mut index: u32 = 0;
        let mut message_ids = MESSAGEIDS.get().write().unwrap();
        match message_ids.ids.get_mut(&sender_id.to_bytes()) {
            Some(mut id) => {
                if id.timestamp == timestamp {
                    index = id.last_index + 1;
                }
                id.timestamp = timestamp;
                id.last_index = index;
            }
            _ => {
                message_ids.ids.insert(
                    sender_id.to_bytes(),
                    MessageId {
                        timestamp,
                        last_index: 0,
                    },
                );
            }
        }

        let sender_crc = crc::crc64::checksum_iso(&sender_id.to_bytes());
        let mut buff = sender_crc.to_be_bytes().to_vec();
        let mut time_bytes = timestamp.to_be_bytes().to_vec();
        let mut index_bytes = index.to_be_bytes().to_vec();

        buff.append(&mut time_bytes);
        buff.append(&mut index_bytes);
        buff
    }

    pub fn generate_group_message_id(
        group_id: &Vec<u8>,
        sender_id: &PeerId,
        index: u32,
    ) -> Vec<u8> {
        let group_crc = crc::crc64::checksum_iso(group_id);
        let sender_crc = crc::crc64::checksum_iso(&sender_id.to_bytes());
        let mut buff0 = group_crc.to_be_bytes().to_vec();
        let mut buff = sender_crc.to_be_bytes().to_vec();
        let mut index_bytes = index.to_be_bytes().to_vec();

        buff0.append(&mut buff);
        buff0.append(&mut index_bytes);
        buff0
    }

    // // create DB key from conversation ID, timestamp
    // fn get_db_key_from_vec(conversation_id: Vec<u8>, timestamp: u64) -> Vec<u8> {
    //     let mut timestamp_bytes = timestamp.to_be_bytes().to_vec();
    //     let mut userid_bytes = timestamp.to_be_bytes().to_vec();
    //     let mut key_bytes = conversation_id;

    //     userid_bytes.append(&mut key_bytes);
    //     userid_bytes.append(&mut timestamp_bytes);
    //     userid_bytes
    // }

    // /// save failed message
    // pub fn save_failed_outgoing_message(user_id: PeerId, conversation_id: PeerId, contents: String){
    //     let timestamp = Timestamp::get_timestamp();
    //     let key = Self::get_db_key_from_vec(conversation_id.to_bytes(), timestamp);

    //     // create chat message
    //     let message = FailedMessage {
    //         user_id: user_id.to_bytes(),
    //         conversation_id: conversation_id.to_bytes(),
    //         message: contents,
    //         last_try: timestamp,
    //         created_at: timestamp,
    //         try_count: 1,
    //     };

    //     let failed_meesaging = FAILEDMESSAGING.get().write().unwrap();

    //     // save message in data base
    //     if let Err(e) = failed_meesaging.tree.insert(key, message) {
    //         log::error!("Error saving failed chat message to data base: {}", e);
    //     }

    //     // flush trees to disk
    //     if let Err(e) = failed_meesaging.tree.flush() {
    //         log::error!("Error failed chat messages flush: {}", e);
    //     }
    // }

    fn save_unconfirmed_message(
        message_id: &Vec<u8>,
        receiver: &PeerId,
        container: &proto::Container,
    ) {
        let new_entry = UnConfirmedMessage {
            receiver_id: receiver.to_bytes(),
            container: container.encode_to_vec(),
            last_sent: Timestamp::get_timestamp(),
            message_id: message_id.clone(),
            retry: 0,
        };
        let unconfirmed = UNCONFIRMED.get().write().unwrap();

        //
        if let Err(e) = unconfirmed
            .unconfirmed
            .insert(container.signature.clone(), new_entry)
        {
            log::error!("{}", e);
        }
        // flush
        if let Err(e) = unconfirmed.unconfirmed.flush() {
            log::error!("Error unconfirmed table flush: {}", e);
        }
    }

    // process confirmation message and return (sender_id, message_id)
    pub fn on_confirmed_message(signature: &Vec<u8>) -> Option<Vec<u8>> {
        let unconfirmed = UNCONFIRMED.get().write().unwrap();

        // remove unconfirmed from DB
        match unconfirmed.unconfirmed.remove(signature) {
            Ok(v) => {
                if let Err(e) = unconfirmed.unconfirmed.flush() {
                    log::error!("Error unconfirmed table flush: {}", e);
                }

                match v {
                    Some(unconfirmed) => {
                        return Some(unconfirmed.message_id.clone());
                    }
                    _ => {}
                }
            }
            Err(e) => {
                log::error!("{}", e);
            }
        }
        None
    }

    /// pack, sign and schedule a message for sending
    pub fn pack_and_send_message(
        user_account: &UserAccount,
        receiver: &PeerId,
        data: &Vec<u8>,
        message_id: Option<&Vec<u8>>,
        is_common_message: bool,
    ) -> Result<Vec<u8>, String> {
        // // encrypt data
        // // TODO: slize data to 64K
        // let (encryption_result, nonce) = Crypto::encrypt(data.clone(), user_account.to_owned(), receiver.clone());

        // let mut encrypted: Vec<proto::Data> = Vec::new();
        // match encryption_result {
        //     Some(encrypted_chunk) => {
        //         let data_message = proto::Data{ nonce, data: encrypted_chunk };

        //         log::info!("data len: {}", data_message.encoded_len());

        //         encrypted.push(data_message);
        //     },
        //     None => return Err("Encryption error occurred".to_string()),
        // }

        // log::info!("sender_id: {}, receiver_id: {}", user_account.id.to_bytes().len(), receiver.to_bytes().len());

        let envelop_payload = proto::EnvelopPayload {
            payload: Some(proto::envelop_payload::Payload::Encrypted(
                proto::Encrypted { data: data.clone() },
            )),
        };

        // let payload = proto::Encrypted{data: data.clone()};

        // let mut message_buf = Vec::with_capacity(payload.encoded_len());
        // payload
        //     .encode(&mut message_buf)
        //     .expect("Vec<u8> provides capacity as needed");

        // create envelope
        let envelope = proto::Envelope {
            sender_id: user_account.id.to_bytes(),
            receiver_id: receiver.to_bytes(),
            //payload: proto::Encrypted{data: encrypted}.encode_to_vec(),
            //payload: proto::Encrypted{data: data.clone()}.encode_to_vec(),
            payload: envelop_payload.encode_to_vec(),
        };

        // debug
        log::info!("envelope len: {}", envelope.encoded_len());

        // encode envelope
        let mut envelope_buf = Vec::with_capacity(envelope.encoded_len());
        envelope
            .encode(&mut envelope_buf)
            .expect("Vec<u8> provides capacity as needed");

        // sign message
        if let Ok(signature) = user_account.keys.sign(&envelope_buf) {
            // create container
            let container = proto::Container {
                signature: signature.clone(),
                envelope: Some(envelope),
            };

            // in common message case, save into unconfirmed table
            if is_common_message {
                Self::save_unconfirmed_message(message_id.unwrap(), receiver, &container);
            }

            // schedule message for sending
            Self::schedule_message(receiver.clone(), container);

            // return signature
            Ok(signature)
        } else {
            return Err("messaging signing error".to_string());
        }
    }

    /// schedule a message
    ///
    /// schedule a message for sending.
    /// This function adds the message to the ring buffer for sending.
    /// This buffer is checked regularly by libqaul for sending.
    ///
    fn schedule_message(receiver: PeerId, container: proto::Container) {
        let msg = ScheduledMessage {
            receiver,
            container,
        };

        // add it to sending queue
        let mut messaging = MESSAGING.get().write().unwrap();
        messaging.to_send.push_back(msg);
    }

    /// Check Scheduler
    ///
    /// Check if there is a message scheduled for sending.
    ///
    pub fn check_scheduler() -> Option<(PeerId, ConnectionModule, Vec<u8>)> {
        let message_item: Option<ScheduledMessage>;

        // get scheduled messaging buffer
        {
            let mut messaging = MESSAGING.get().write().unwrap();
            message_item = messaging.to_send.pop_front();
        }

        if let Some(message) = message_item {
            // check for route
            if let Some(route) = RoutingTable::get_route_to_user(message.receiver) {
                // create binary message
                let data = message.container.encode_to_vec();

                // return information
                return Some((route.node, route.module, data));
            } else {
                log::trace!("No route found to user {}", message.receiver.to_base58());

                // reschedule if no route is found
                Self::schedule_message(message.receiver, message.container);
            }
        }

        None
    }

    /// TODO: send received confirmation message
    pub fn send_confirmation(
        user_id: &PeerId,
        receiver_id: &PeerId,
        signature: &Vec<u8>,
    ) -> Result<Vec<u8>, String> {
        if let Some(user) = UserAccounts::get_by_id(user_id.clone()) {
            // // create timestamp
            let timestamp = Timestamp::get_timestamp();

            // // pack message
            let send_message = proto::Messaging {
                message: Some(proto::messaging::Message::ConfirmationMessage(
                    proto::Confirmation {
                        signature: signature.clone(),
                        received_at: timestamp,
                    },
                )),
            };

            // encode chat message
            let mut message_buf = Vec::with_capacity(send_message.encoded_len());
            send_message
                .encode(&mut message_buf)
                .expect("Vec<u8> provides capacity as needed");

            // // send message via messaging
            Self::pack_and_send_message(&user, receiver_id, &message_buf, None, false)
        } else {
            return Err("invalid user_id".to_string());
        }
    }

    /// received message from qaul_messaging behaviour
    pub fn received(received: QaulMessagingReceived) {
        // decode message container
        match proto::Container::decode(&received.data[..]) {
            Ok(container) => {
                if let Some(envelope) = container.envelope.clone() {
                    match PeerId::from_bytes(&envelope.receiver_id) {
                        Ok(receiver_id) => {
                            // check if message is local user account
                            if UserAccounts::is_account(receiver_id) {
                                // save message
                                MessagingProcess::process_received_message(container);
                            } else {
                                // schedule it for further sending otherwise
                                Self::schedule_message(receiver_id, container);
                            }
                        }
                        Err(e) => log::error!(
                            "invalid peer ID of message {}: {}",
                            bs58::encode(container.signature).into_string(),
                            e
                        ),
                    }
                }
            }
            Err(e) => log::error!("Messaging container decoding error: {}", e),
        }
    }
}
