// Copyright (c) 2022 Open Community Project Association https://ocpa.ch
// This software is published under the AGPLv3 license.

//! # Qaul Group Service
//!
//! The Group service sends and receives messages and files into group members.
//! The Group messages carry on the Messaging service
//! Messaging(Group(GroupContainer(...)))

use libp2p::PeerId;
use prost::Message;
use serde::{Deserialize, Serialize};
use sled_extensions::{bincode::Tree, DbExt};
use state::Storage;
use std::collections::BTreeMap;
use std::{convert::TryInto, sync::RwLock};

use super::chat::{self, Chat};
use super::group::conversation_id::ConversationId;
use super::messaging::proto;
use super::messaging::Messaging;
use crate::node::user_accounts::{UserAccount, UserAccounts};
use crate::rpc::Rpc;
use crate::storage::database::DataBase;
use crate::utilities::timestamp;

pub mod conversation_id;
mod manage;
mod member;
mod message;

pub use manage::Manage;
use member::Member;
pub use message::GroupMessage;

/// Import protobuf message definition generated by
/// the rust module prost-build.
pub mod proto_rpc {
    include!("qaul.rpc.group.rs");
}
pub mod proto_net {
    include!("qaul.net.group.rs");
}

/// mutable state of all user groups
pub static GROUPSOFUSER: Storage<RwLock<GroupsOfUser>> = Storage::new();

/// Structure to management for groups.
#[derive(Clone)]
pub struct Groups {
    //DB reference
    pub db_ref: Tree<Group>,
    //DB invited ref
    pub invited_ref: Tree<GroupInvited>,
    // last group index
    pub last_group: u64,
    // id mapping group_id => index in DB
    pub group_ids: BTreeMap<Vec<u8>, u64>,
}

impl Groups {
    pub fn group_id_to_index(&self, group_id: &Vec<u8>) -> u64 {
        if self.group_ids.contains_key(group_id) {
            return *self.group_ids.get(group_id).unwrap();
        }
        return 0;
    }
}

/// Structure of user => groups mapping for storage
pub struct GroupsOfUser {
    pub groups_of_user: BTreeMap<Vec<u8>, Groups>,
}

/// Structure of group member
#[derive(Serialize, Deserialize, Clone)]
pub struct GroupMember {
    // user id
    pub user_id: Vec<u8>,
    // role = 0 => member, 255 => admin
    pub role: i32,
    // joined at
    pub joined_at: u64,
    // state for future using
    pub state: i32,
    // last message index
    pub last_message_index: u32,
}

/// Structure of Group
#[derive(Serialize, Deserialize, Clone)]
pub struct GroupInvited {
    /// group id
    pub id: Vec<u8>,
    /// sender id
    pub sender_id: Vec<u8>,
    /// received at
    pub received_at: u64,
    /// created at
    pub created_at: u64,
    /// group name
    pub name: String,
    /// group member count
    pub member_count: u32,
}

/// Structure of Group
#[derive(Serialize, Deserialize, Clone)]
pub struct Group {
    /// group id
    pub id: Vec<u8>,
    /// group name
    pub name: String,
    /// is direct chat group
    pub is_direct_chat: bool,
    /// created at
    pub created_at: u64,
    /// creator id
    pub creator_id: Vec<u8>,
    /// members
    pub members: BTreeMap<Vec<u8>, GroupMember>,
}

/// Group module to process transfer, receive and RPC commands
impl Group {
    /// get a group member
    pub fn get_member(&self, user_id: &Vec<u8>) -> Option<&GroupMember> {
        if self.members.contains_key(user_id) {
            return self.members.get(user_id);
        }
        None
    }

    /// initialize group chat module
    pub fn init() {
        let groups_of_user = GroupsOfUser {
            groups_of_user: BTreeMap::new(),
        };
        GROUPSOFUSER.set(RwLock::new(groups_of_user));
    }
    /// group exist
    pub fn group_exists(user_id: &PeerId, group_id: &Vec<u8>) -> bool {
        let user_groups = Self::get_groups_of_user(user_id);
        let idx = user_groups.group_id_to_index(group_id);
        idx > 0
    }

    /// member exist
    pub fn _is_group_member_exist(
        user_id: &PeerId,
        group_id: &Vec<u8>,
        member_id: &Vec<u8>,
    ) -> bool {
        let user_groups = Self::get_groups_of_user(user_id);
        let idx = user_groups.group_id_to_index(group_id);
        if idx == 0 {
            return false;
        }

        if let Ok(res) = user_groups.db_ref.get(&idx.to_be_bytes()) {
            match res {
                Some(group) => {
                    return group.members.contains_key(member_id);
                }
                _ => {}
            }
        }
        false
    }

    /// get group member    
    pub fn _get_group_member(
        user_id: &PeerId,
        group_id: &Vec<u8>,
        member_id: &Vec<u8>,
    ) -> Option<GroupMember> {
        let user_groups = Self::get_groups_of_user(user_id);
        let idx = user_groups.group_id_to_index(group_id);
        if idx == 0 {
            return None;
        }
        if let Ok(res) = user_groups.db_ref.get(&idx.to_be_bytes()) {
            match res {
                Some(group) => {
                    if let Some(member) = group.members.get(member_id) {
                        return Some(member.clone());
                    }
                }
                _ => {}
            }
        }
        None
    }

    /// update group member
    pub fn update_group_member(user_id: &PeerId, group_id: &Vec<u8>, member: &GroupMember) {
        let user_groups = Self::get_groups_of_user(user_id);
        let idx = user_groups.group_id_to_index(group_id);
        if idx == 0 {
            return;
        }
        if let Ok(res) = user_groups.db_ref.get(&idx.to_be_bytes()) {
            match res {
                Some(mut group) => {
                    group.members.insert(member.user_id.clone(), member.clone());
                    // update DB
                    if let Err(_e) = user_groups.db_ref.insert(&idx.to_be_bytes(), group) {
                        log::error!("group db updating error");
                    }

                    if let Err(_e) = user_groups.db_ref.flush() {
                        log::error!("group db flush error");
                    }
                }
                _ => {}
            }
        }
    }

    /// update group
    pub fn update_group(user_id: &PeerId, group: &Group) {
        let user_groups = Self::get_groups_of_user(user_id);
        let idx = user_groups.group_id_to_index(&group.id);
        if idx == 0 {
            return;
        }

        if let Err(_e) = user_groups.db_ref.insert(&idx.to_be_bytes(), group.clone()) {
            log::error!("group db updating error");
        }

        if let Err(_e) = user_groups.db_ref.flush() {
            log::error!("group db flush error");
        }
    }

    /// get group name
    pub fn get_group_name(user_id: &PeerId, group_id: &Vec<u8>) -> Option<String> {
        let groups = Self::get_groups_of_user(user_id);
        let idx = groups.group_id_to_index(group_id);
        if idx == 0 {
            return None;
        }
        if let Ok(res) = groups.db_ref.get(&idx.to_be_bytes()) {
            match res {
                Some(group) => {
                    return Some(group.name.clone());
                }
                _ => {}
            }
        }
        None
    }

    /// update group name
    pub fn _update_group_name(user_id: &PeerId, group_id: &Vec<u8>, name: String) {
        let user_groups = Self::get_groups_of_user(user_id);
        let idx = user_groups.group_id_to_index(group_id);
        if idx == 0 {
            return;
        }
        if let Ok(res) = user_groups.db_ref.get(&idx.to_be_bytes()) {
            match res {
                Some(mut group) => {
                    group.name = name.clone();
                    // update DB
                    if let Err(_e) = user_groups.db_ref.insert(&idx.to_be_bytes(), group) {
                        log::error!("group db updating error");
                    }
                    if let Err(_e) = user_groups.db_ref.flush() {
                        log::error!("group db flush error");
                    }
                }
                _ => {}
            }
        }
    }

    /// get group
    pub fn get_group(user_id: &PeerId, group_id: &Vec<u8>) -> Result<Group, String> {
        let user_groups = Self::get_groups_of_user(user_id);
        let idx = user_groups.group_id_to_index(group_id);
        if idx == 0 {
            return Err("group no exists".to_string());
        }
        if let Ok(res) = user_groups.db_ref.get(&idx.to_be_bytes()) {
            match res {
                Some(group) => {
                    return Ok(group.clone());
                }
                _ => {}
            }
        }
        Err("db error".to_string())
    }

    /// update user's groups
    pub fn update_groups_of_user(user_id: &PeerId, groups: Groups) {
        let mut groups_of_user = GROUPSOFUSER.get().write().unwrap();
        groups_of_user
            .groups_of_user
            .insert(user_id.to_bytes(), groups);
    }

    /// get user's groups
    pub fn get_groups_of_user(user_id: &PeerId) -> Groups {
        let mut groups_of_user = GROUPSOFUSER.get().write().unwrap();
        if !groups_of_user
            .groups_of_user
            .contains_key(&user_id.to_bytes())
        {
            let new_groups_of_user = Self::create_groups_of_user(user_id);
            groups_of_user
                .groups_of_user
                .insert(user_id.to_bytes(), new_groups_of_user);
        }
        let groups = groups_of_user
            .groups_of_user
            .get(&user_id.to_bytes())
            .unwrap();
        groups.clone()
    }

    /// create new user's groups from DB
    fn create_groups_of_user(user_id: &PeerId) -> Groups {
        let db = DataBase::get_user_db(user_id.clone());
        let tree: Tree<Group> = db.open_bincode_tree("groups").unwrap();
        let invited: Tree<GroupInvited> = db.open_bincode_tree("group_invited").unwrap();

        // // get last key
        let last_group: u64;
        match tree.iter().last() {
            Some(Ok((ivec, _))) => {
                let i = ivec.to_vec();
                match i.try_into() {
                    Ok(arr) => {
                        last_group = u64::from_be_bytes(arr);
                    }
                    Err(e) => {
                        log::error!("couldn't convert ivec to u64: {:?}", e);
                        last_group = 0;
                    }
                }
            }
            None => {
                last_group = 0;
            }
            Some(Err(e)) => {
                log::error!("Sled feed table error: {}", e);
                last_group = 0;
            }
        }

        let mut ids: BTreeMap<Vec<u8>, u64> = BTreeMap::new();
        //initialize group_id mapping
        for res in tree.iter() {
            match res {
                Ok((idx, group)) => {
                    let index = idx.to_vec();
                    ids.insert(group.id, u64::from_be_bytes(index.try_into().unwrap()));
                }
                Err(e) => {
                    log::error!("Error retrieving feed message from data base: {}", e);
                }
            }
        }

        let groups = Groups {
            db_ref: tree,
            invited_ref: invited,
            last_group,
            group_ids: ids,
        };
        groups
    }

    /// Send capsuled group message through messaging service
    pub fn send_group_message_through_message(
        user_account: &UserAccount,
        receiver: &PeerId,
        data: &Vec<u8>,
    ) {
        // create direct chat room
        let group_id = ConversationId::from_peers(&user_account.id, &receiver);
        if !Self::group_exists(&user_account.id, &group_id.to_bytes()) {
            Manage::create_new_direct_chat_group(&user_account.id, &receiver);
        }

        //get last index
        let group;
        match Self::get_group(&user_account.id, &group_id.to_bytes()) {
            Ok(v) => {
                group = v;
            }
            Err(_error) => {
                return;
            }
        }

        let mut my_member;
        match group.get_member(&user_account.id.to_bytes()) {
            Some(v) => {
                my_member = v.clone();
            }
            _ => {
                return;
            }
        }

        let last_index = my_member.last_message_index + 1;
        let message_id =
            Messaging::generate_group_message_id(&group.id, &user_account.id, last_index);
        let common_message = proto::CommonMessage {
            message_id: message_id.clone(),
            conversation_id: group.id.clone(),
            sent_at: timestamp::Timestamp::get_timestamp(),
            payload: Some(proto::common_message::Payload::GroupMessage(
                proto::GroupMessage {
                    content: data.clone(),
                },
            )),
        };

        let send_message = proto::Messaging {
            message: Some(proto::messaging::Message::CommonMessage(
                common_message.clone(),
            )),
        };

        // send message via messaging
        match Messaging::pack_and_send_message(
            user_account,
            &receiver,
            &send_message.encode_to_vec(),
            Some(&message_id),
            true,
        ) {
            Ok(_) => {
                // save
                Chat::save_outgoing_message(
                    &user_account.id,
                    &receiver,
                    &group_id,
                    &message_id,
                    chat::rpc_proto::ContentType::Group.try_into().unwrap(),
                    data,
                    chat::rpc_proto::MessageStatus::Sending,
                );
                //update member state
                my_member.last_message_index = last_index;
                Self::update_group_member(&user_account.id, &group_id.to_bytes(), &my_member);
            }
            Err(err) => {
                log::error!("group message sending failed {}", err);
            }
        }
    }

    /// BroadCast group updated to all members
    fn post_group_update(my_user_id: &PeerId, group_id: &Vec<u8>) {
        let groups = Self::get_groups_of_user(my_user_id);

        log::error!("post_group_update!");
        let group_idx = groups.group_id_to_index(group_id);
        if group_idx == 0 {
            return;
        }

        log::error!("post_group_update111!");

        let group = groups
            .db_ref
            .get(&group_idx.to_be_bytes())
            .unwrap()
            .unwrap();

        //create group notify messge and post to all members
        let mut members: Vec<proto_net::Member> = vec![];
        for m in group.members.values() {
            if m.state > 0 {
                members.push(proto_net::Member {
                    user_id: m.user_id.clone(),
                    role: m.role,
                    state: m.state,
                    joined_at: m.joined_at,
                    last_message_index: m.last_message_index,
                });
            }
        }

        let notify = proto_net::GroupNotify {
            group_id: group_id.clone(),
            group_name: group.name.clone(),
            created_at: group.created_at,
            creator_id: group.creator_id.clone(),
            members,
        };

        let send_message = proto::Messaging {
            message: Some(proto::messaging::Message::GroupNotifyMessage(
                proto::GroupNotifyMessage {
                    content: notify.encode_to_vec(),
                },
            )),
        };

        //broad cast to all group members
        if let Some(user_account) = UserAccounts::get_by_id(*my_user_id) {
            for user_id in group.members.keys() {
                let receiver = PeerId::from_bytes(&user_id.clone()).unwrap();
                if receiver != *my_user_id {
                    if let Err(error) = Messaging::pack_and_send_message(
                        &user_account,
                        &receiver,
                        &send_message.encode_to_vec(),
                        None,
                        false,
                    ) {
                        log::error!("send group notify error {}", error);
                    }
                }
            }
        }
    }

    /// Process group notify message from network
    pub fn on_notify(sender_id: &PeerId, receiver_id: &PeerId, data: &Vec<u8>) {
        match proto_net::GroupNotify::decode(&data[..]) {
            Ok(notify) => {
                manage::Manage::on_group_notify(
                    &sender_id.to_bytes(),
                    &receiver_id.to_bytes(),
                    &notify,
                );
            }
            _ => {
                log::error!("invalid group notify message");
            }
        }
    }

    /// Process incoming NET messages for group chat module
    pub fn net(sender_id: &PeerId, receiver_id: &PeerId, data: &Vec<u8>) {
        //check receiver id is in users list
        let user;
        match UserAccounts::get_by_id(receiver_id.clone()) {
            Some(usr) => {
                user = usr;
            }
            None => {
                log::error!("no user id={}", receiver_id);
                return;
            }
        }

        match proto_net::GroupContainer::decode(&data[..]) {
            Ok(messaging) => match messaging.message {
                Some(proto_net::group_container::Message::InviteMember(invite_member)) => {
                    log::info!("group::on_receive_invite");
                    Member::on_be_invited(&sender_id, &receiver_id, &invite_member);
                }
                Some(proto_net::group_container::Message::Removed(_removed)) => {
                    log::info!("group::on_removed");
                }
                Some(proto_net::group_container::Message::ReplyInvite(reply_invite)) => {
                    log::info!("group::on_answered for invite");
                    if let Err(error) =
                        Member::on_reply_invite(&sender_id, &receiver_id, &reply_invite)
                    {
                        log::error!("group on_reply_invite error {}", error);
                    } else {
                        if reply_invite.accept {
                            Self::post_group_update(&user.id, &reply_invite.group_id);
                        }
                    }
                }
                None => {
                    log::error!(
                        "file share message from {} was empty",
                        sender_id.to_base58()
                    )
                }
            },
            Err(e) => {
                log::error!(
                    "Error decoding FileSharing Message from {} to {}: {}",
                    sender_id.to_base58(),
                    receiver_id.to_base58(),
                    e
                );
            }
        }
    }

    /// Process incoming RPC request messages for group chat module
    pub fn rpc(data: Vec<u8>, user_id: Vec<u8>) {
        let my_user_id = PeerId::from_bytes(&user_id).unwrap();

        match proto_rpc::Group::decode(&data[..]) {
            Ok(group) => {
                match group.message {
                    Some(proto_rpc::group::Message::GroupCreateRequest(group_create_req)) => {
                        let id = Manage::create_new_group(
                            &my_user_id,
                            group_create_req.group_name.clone(),
                        );
                        //make response
                        let proto_message = proto_rpc::Group {
                            message: Some(proto_rpc::group::Message::GroupCreateResponse(
                                proto_rpc::GroupCreateResponse {
                                    group_id: id,
                                    result: Some(proto_rpc::GroupResult {
                                        status: true,
                                        message: "".to_string(),
                                    }),
                                },
                            )),
                        };

                        // send message
                        Rpc::send_message(
                            proto_message.encode_to_vec(),
                            crate::rpc::proto::Modules::Group.into(),
                            "".to_string(),
                            Vec::new(),
                        );
                    }
                    Some(proto_rpc::group::Message::GroupRenameRequest(group_rename_req)) => {
                        let mut status = true;
                        let mut message: String = "".to_string();
                        if let Err(err) = Manage::rename_group(
                            &my_user_id,
                            &group_rename_req.group_id,
                            group_rename_req.group_name.clone(),
                        ) {
                            status = false;
                            message = err.clone();
                        }

                        let proto_message = proto_rpc::Group {
                            message: Some(proto_rpc::group::Message::GroupRenameResponse(
                                proto_rpc::GroupRenameResponse {
                                    group_id: group_rename_req.group_id.clone(),
                                    group_name: group_rename_req.group_name.clone(),
                                    result: Some(proto_rpc::GroupResult { status, message }),
                                },
                            )),
                        };

                        // send message
                        Rpc::send_message(
                            proto_message.encode_to_vec(),
                            crate::rpc::proto::Modules::Group.into(),
                            "".to_string(),
                            Vec::new(),
                        );

                        //post updates
                        if status {
                            Self::post_group_update(&my_user_id, &group_rename_req.group_id);
                        }
                    }
                    Some(proto_rpc::group::Message::GroupInfoRequest(group_info_req)) => {
                        match Manage::group_info(&my_user_id, &group_info_req.group_id) {
                            Ok(res) => {
                                let proto_message = proto_rpc::Group {
                                    message: Some(proto_rpc::group::Message::GroupInfoResponse(
                                        res,
                                    )),
                                };

                                // send message
                                Rpc::send_message(
                                    proto_message.encode_to_vec(),
                                    crate::rpc::proto::Modules::Group.into(),
                                    "".to_string(),
                                    Vec::new(),
                                );
                            }
                            Err(err) => {
                                log::error!("Get group info error, {}", err);
                            }
                        }
                    }
                    Some(proto_rpc::group::Message::GroupListRequest(_group_list_req)) => {
                        let list = Manage::group_list(&my_user_id);
                        let proto_message = proto_rpc::Group {
                            message: Some(proto_rpc::group::Message::GroupListResponse(list)),
                        };
                        // send message
                        Rpc::send_message(
                            proto_message.encode_to_vec(),
                            crate::rpc::proto::Modules::Group.into(),
                            "".to_string(),
                            Vec::new(),
                        );
                    }
                    Some(proto_rpc::group::Message::GroupInvitedRequest(_group_invited_req)) => {
                        let invited = Manage::invited_list(&my_user_id);
                        let proto_message = proto_rpc::Group {
                            message: Some(proto_rpc::group::Message::GroupInvitedResponse(invited)),
                        };
                        // send message
                        Rpc::send_message(
                            proto_message.encode_to_vec(),
                            crate::rpc::proto::Modules::Group.into(),
                            "".to_string(),
                            Vec::new(),
                        );
                    }
                    Some(proto_rpc::group::Message::GroupInviteMemberRequest(invite_req)) => {
                        let mut status = true;
                        let mut message: String = "".to_string();
                        if let Err(err) = Member::invite(
                            &my_user_id,
                            &invite_req.group_id,
                            &PeerId::from_bytes(&invite_req.user_id).unwrap(),
                        ) {
                            status = false;
                            message = err.clone();
                            log::error!("Get group info error, {}", err);
                        }
                        let proto_message = proto_rpc::Group {
                            message: Some(proto_rpc::group::Message::GroupInviteMemberResponse(
                                proto_rpc::GroupInviteMemberResponse {
                                    group_id: invite_req.group_id.clone(),
                                    user_id: invite_req.user_id.clone(),
                                    result: Some(proto_rpc::GroupResult { status, message }),
                                },
                            )),
                        };

                        // send message
                        Rpc::send_message(
                            proto_message.encode_to_vec(),
                            crate::rpc::proto::Modules::Group.into(),
                            "".to_string(),
                            Vec::new(),
                        );
                    }
                    Some(proto_rpc::group::Message::GroupReplyInviteRequest(reply_req)) => {
                        let mut status = true;
                        let mut message: String = "".to_string();

                        if let Err(err) = Member::reply_invite(
                            &my_user_id,
                            &reply_req.group_id,
                            &PeerId::from_bytes(&reply_req.user_id).unwrap(),
                            reply_req.accept,
                        ) {
                            status = false;
                            message = err.clone();
                            log::error!("Get group info error, {}", err);
                        }
                        let proto_message = proto_rpc::Group {
                            message: Some(proto_rpc::group::Message::GroupReplyInviteResponse(
                                proto_rpc::GroupReplyInviteResponse {
                                    group_id: reply_req.group_id.clone(),
                                    user_id: reply_req.user_id.clone(),
                                    result: Some(proto_rpc::GroupResult { status, message }),
                                },
                            )),
                        };

                        // send message
                        Rpc::send_message(
                            proto_message.encode_to_vec(),
                            crate::rpc::proto::Modules::Group.into(),
                            "".to_string(),
                            Vec::new(),
                        );
                    }

                    Some(proto_rpc::group::Message::GroupRemoveMemberRequest(remove_req)) => {
                        let mut status = true;
                        let mut message: String = "".to_string();

                        if let Err(err) = Member::remove(
                            &my_user_id,
                            &remove_req.group_id,
                            &PeerId::from_bytes(&remove_req.user_id).unwrap(),
                        ) {
                            status = false;
                            message = err.clone();
                            log::error!("Get group info error, {}", err);
                        }

                        let proto_message = proto_rpc::Group {
                            message: Some(proto_rpc::group::Message::GroupRemoveMemberResponse(
                                proto_rpc::GroupRemoveMemberResponse {
                                    group_id: remove_req.group_id.clone(),
                                    user_id: remove_req.user_id.clone(),
                                    result: Some(proto_rpc::GroupResult { status, message }),
                                },
                            )),
                        };

                        // send message
                        Rpc::send_message(
                            proto_message.encode_to_vec(),
                            crate::rpc::proto::Modules::Group.into(),
                            "".to_string(),
                            Vec::new(),
                        );

                        if status {
                            Self::post_group_update(&my_user_id, &remove_req.group_id);
                        }
                    }
                    _ => {
                        log::error!("Unhandled Protobuf Group chat message");
                    }
                }
            }
            Err(error) => {
                log::error!("{:?}", error);
            }
        }
    }
}
