// Copyright (c) 2022 Open Community Project Association https://ocpa.ch
// This software is published under the AGPLv3 license.

//! # Qaul Group Service
//!
//! The Group service sends and receives messages and files into group members.
//! The Group messages carry on the Messaging service
//! Messaging(Group(GroupContainer(...)))

use libp2p::PeerId;
use prost::Message;
use serde::{Deserialize, Serialize};
use sled_extensions::{bincode::Tree, DbExt};
use state::Storage;
use std::collections::BTreeMap;
use std::{convert::TryInto, sync::RwLock};

use super::chat::{self, Chat, ChatStorage};
use super::group::conversation_id::ConversationId;
use super::messaging::{proto, Messaging, MessagingServiceType};
use crate::node::user_accounts::{UserAccount, UserAccounts};
use crate::rpc::Rpc;
use crate::storage::database::DataBase;
use crate::utilities::timestamp;

pub mod conversation_id;
mod manage;
mod member;
mod message;

pub use manage::Manage;
use member::Member;
pub use message::GroupMessage;

/// Import protobuf message definition generated by
/// the rust module prost-build.
pub mod proto_rpc {
    include!("qaul.rpc.group.rs");
}
pub mod proto_net {
    include!("qaul.net.group.rs");
}

/// mutable state of all user groups
pub static GROUPSTORAGE: Storage<RwLock<GroupStorage>> = Storage::new();

/// Group DB links for user account
#[derive(Clone)]
pub struct GroupAccountDb {
    /// group DB reference
    pub groups: Tree<Group>,
    /// invited DB ref
    pub invited: Tree<GroupInvited>,
}

/// qaul Chat Conversation Storage
pub struct GroupStorage {
    /// data base tree references accessible
    /// by user account
    db_ref: BTreeMap<Vec<u8>, GroupAccountDb>,
}

impl GroupStorage {
    /// Initialize Group Storage
    pub fn init() {
        let group_storage = GroupStorage {
            db_ref: BTreeMap::new(),
        };
        GROUPSTORAGE.set(RwLock::new(group_storage));
    }

    /// get DB refs for user account
    fn get_db_ref(account_id: PeerId) -> GroupAccountDb {
        // check if user account data exists
        {
            // get chat state
            let group_storage = GROUPSTORAGE.get().read().unwrap();

            // check if user account ID is in map
            if let Some(group_account_db) = group_storage.db_ref.get(&account_id.to_bytes()) {
                return GroupAccountDb {
                    groups: group_account_db.groups.clone(),
                    invited: group_account_db.invited.clone(),
                };
            }
        }

        // create group account db entry if it does not exist
        let group_account_db = Self::create_groupaccountdb(account_id);

        // return group_account_db structure
        GroupAccountDb {
            groups: group_account_db.groups.clone(),
            invited: group_account_db.invited.clone(),
        }
    }

    /// create group account db entry when it does not exist
    fn create_groupaccountdb(account_id: PeerId) -> GroupAccountDb {
        // get user data base
        let db = DataBase::get_user_db(account_id);

        // open trees
        let groups: Tree<Group> = db.open_bincode_tree("groups").unwrap();
        let invited: Tree<GroupInvited> = db.open_bincode_tree("invited").unwrap();

        let group_account_db = GroupAccountDb { groups, invited };

        // get group storage for writing
        let mut group_storage = GROUPSTORAGE.get().write().unwrap();

        // add user to state
        group_storage
            .db_ref
            .insert(account_id.to_bytes(), group_account_db.clone());

        // return structure
        group_account_db
    }

    /// get a group from data base
    pub fn get_group(account_id: PeerId, group_id: Vec<u8>) -> Option<Group> {
        // get DB ref
        let db_ref = Self::get_db_ref(account_id);

        // get group
        match db_ref.groups.get(group_id) {
            Ok(group) => {
                return group;
            }
            Err(e) => log::error!("{}", e),
        }

        None
    }

    /// Check if a group exists in the data base
    pub fn group_exists(account_id: PeerId, group_id: Vec<u8>) -> bool {
        // get DB ref
        let db_ref = Self::get_db_ref(account_id);

        // check id group exists
        match db_ref.groups.contains_key(group_id) {
            Ok(exists) => {
                return exists;
            }
            Err(e) => log::error!("{}", e),
        }

        false
    }

    /// Save a group into the data base
    ///
    /// This function overwrites an already existing group entry or
    /// creates a new one.
    pub fn save_group(account_id: PeerId, group: Group) {
        // get DB ref
        let db_ref = Self::get_db_ref(account_id);

        // save group in data base
        if let Err(e) = db_ref.groups.insert(group.id.clone(), group) {
            log::error!("Error saving group to data base: {}", e);
        }
        // flush trees to disk
        if let Err(e) = db_ref.groups.flush() {
            log::error!("Error groups flush: {}", e);
        }
    }

    /// get invite
    pub fn get_invite(account_id: PeerId, group_id: Vec<u8>) -> Option<GroupInvited> {
        // get DB ref
        let db_ref = Self::get_db_ref(account_id);

        // get invite
        match db_ref.invited.get(group_id) {
            Ok(invite) => {
                return invite;
            }
            Err(e) => log::error!("{}", e),
        }

        None
    }

    /// Save a group invite into the data base
    ///
    /// This function overwrites an already existing invite entry for
    /// the same group or creates a new one.
    pub fn save_invite(account_id: PeerId, invite: GroupInvited) {
        // get DB ref
        let db_ref = Self::get_db_ref(account_id);

        // save group invite in data base
        if let Err(e) = db_ref.invited.insert(invite.group.id.clone(), invite) {
            log::error!("Error saving group invite to data base: {}", e);
        }
        // flush trees to disk
        if let Err(e) = db_ref.invited.flush() {
            log::error!("Error invited flush: {}", e);
        }
    }

    /// Remove a group invite from the data base
    pub fn remove_invite(account_id: PeerId, group_id: &Vec<u8>) {
        // get DB ref
        let db_ref = Self::get_db_ref(account_id);

        // remove group invite from data base
        if let Err(e) = db_ref.invited.remove(group_id) {
            log::error!("Error removing group invite from data base: {}", e);
        }
        // flush trees to disk
        if let Err(e) = db_ref.invited.flush() {
            log::error!("Error invited flush: {}", e);
        }
    }
}

/// Structure of group member
#[derive(Serialize, Deserialize, Clone)]
pub struct GroupMember {
    // user id
    pub user_id: Vec<u8>,
    // role = 0 => member, 255 => admin
    pub role: i32,
    // joined at
    pub joined_at: u64,
    // state for future using
    pub state: i32,
    // last message index
    pub last_message_index: u32,
}

/// Structure of Group
#[derive(Serialize, Deserialize, Clone)]
pub struct GroupInvited {
    /// sender id
    pub sender_id: Vec<u8>,
    /// received at
    pub received_at: u64,
    /// group info
    pub group: Group,
}

/// Structure of Group
#[derive(Serialize, Deserialize, Clone)]
pub struct Group {
    /// group id
    pub id: Vec<u8>,
    /// group name
    pub name: String,
    /// is direct chat group
    pub is_direct_chat: bool,
    /// created at
    pub created_at: u64,
    /// group revision number
    ///
    /// this number increases with every revision
    pub revision: u32,
    /// members
    pub members: BTreeMap<Vec<u8>, GroupMember>,
}

/// Group module to process transfer, receive and RPC commands
impl Group {
    /// initialize group chat module
    pub fn init() {
        // initialize group storage
        GroupStorage::init();
    }

    /// get a group member
    pub fn get_member(&self, user_id: &Vec<u8>) -> Option<&GroupMember> {
        if self.members.contains_key(user_id) {
            return self.members.get(user_id);
        }
        None
    }

    // REMOVE
    /*
       /// group exists
       pub fn group_exists(user_id: &PeerId, group_id: &Vec<u8>) -> bool {
           let user_groups = Self::get_groups_of_user(user_id);
           let idx = user_groups.group_id_to_index(group_id);
           idx > 0
       }
    */
    // REMOVE
    /*
    /// member exist
    pub fn _group_member_exist(user_id: &PeerId, group_id: &Vec<u8>, member_id: &Vec<u8>) -> bool {
        let user_groups = Self::get_groups_of_user(user_id);
        let idx = user_groups.group_id_to_index(group_id);
        if idx == 0 {
            return false;
        }

        if let Ok(res) = user_groups.groups.get(&idx.to_be_bytes()) {
            match res {
                Some(group) => {
                    return group.members.contains_key(member_id);
                }
                _ => {}
            }
        }
        false
    }
    */

    /// update group member
    pub fn update_group_member(account_id: &PeerId, group_id: &Vec<u8>, member: &GroupMember) {
        if let Some(mut group) = GroupStorage::get_group(account_id.to_owned(), group_id.to_owned())
        {
            // insert member
            group.members.insert(member.user_id.clone(), member.clone());

            // increase revision
            group.revision = group.revision + 1;

            // update DB
            GroupStorage::save_group(account_id.to_owned(), group);

            // send new state to all users
            Group::post_group_update(account_id, group_id);
        }
    }

    // REMOVE
    /*
        /// update group
        pub fn update_group(user_id: &PeerId, group: &Group) {
            let user_groups = Self::get_groups_of_user(user_id);
            let idx = user_groups.group_id_to_index(&group.id);
            if idx == 0 {
                return;
            }

            if let Err(_e) = user_groups.groups.insert(&idx.to_be_bytes(), group.clone()) {
                log::error!("group db updating error");
            }

            if let Err(_e) = user_groups.groups.flush() {
                log::error!("group db flush error");
            }
        }
    */

    /// get group name
    pub fn get_group_name(account_id: &PeerId, group_id: &Vec<u8>) -> Option<String> {
        if let Some(group) = GroupStorage::get_group(account_id.to_owned(), group_id.to_owned()) {
            return Some(group.name.clone());
        }
        None
    }

    /*
        /// update group name
        pub fn _update_group_name(user_id: &PeerId, group_id: &Vec<u8>, name: String) {
            let user_groups = Self::get_groups_of_user(user_id);
            let idx = user_groups.group_id_to_index(group_id);
            if idx == 0 {
                return;
            }
            if let Ok(res) = user_groups.groups.get(&idx.to_be_bytes()) {
                match res {
                    Some(mut group) => {
                        group.name = name.clone();
                        // update DB
                        if let Err(_e) = user_groups.groups.insert(&idx.to_be_bytes(), group) {
                            log::error!("group db updating error");
                        }
                        if let Err(_e) = user_groups.groups.flush() {
                            log::error!("group db flush error");
                        }
                    }
                    _ => {}
                }
            }
        }
    */
    // remove
    /*
       /// get group
       pub fn get_group(account_id: &PeerId, group_id: &Vec<u8>) -> Result<Group, String> {
           let user_groups = Self::get_groups_of_user(account_id);
           let idx = user_groups.group_id_to_index(group_id);
           if idx == 0 {
               return Err("group no exists".to_string());
           }
           if let Ok(res) = user_groups.groups.get(&idx.to_be_bytes()) {
               match res {
                   Some(group) => {
                       return Ok(group.clone());
                   }
                   _ => {}
               }
           }
           Err("db error".to_string())
       }
    */
    /*
       /// update user's groups
       pub fn update_groups_of_user(user_id: &PeerId, groups: Groups) {
           let mut groups_of_user = GROUPSOFUSER.get().write().unwrap();
           groups_of_user
               .groups_of_user
               .insert(user_id.to_bytes(), groups);
       }
    */

    /*
        /// get user's groups
        pub fn get_groups_of_user(user_id: &PeerId) -> Groups {
            let mut groups_of_user = GROUPSOFUSER.get().write().unwrap();
            if !groups_of_user
                .groups_of_user
                .contains_key(&user_id.to_bytes())
            {
                let new_groups_of_user = Self::create_groups_of_user(user_id);
                groups_of_user
                    .groups_of_user
                    .insert(user_id.to_bytes(), new_groups_of_user);
            }
            let groups = groups_of_user
                .groups_of_user
                .get(&user_id.to_bytes())
                .unwrap();
            groups.clone()
        }
    */

    /*
        /// create new user's groups from DB
        fn create_groups_of_user(user_id: &PeerId) -> Groups {
            let db = DataBase::get_user_db(user_id.clone());
            let tree: Tree<Group> = db.open_bincode_tree("groups").unwrap();
            let invited: Tree<GroupInvited> = db.open_bincode_tree("group_invited").unwrap();

            // get last key
            let last_group: u64;
            match tree.iter().last() {
                Some(Ok((ivec, _))) => {
                    let i = ivec.to_vec();
                    match i.try_into() {
                        Ok(arr) => {
                            last_group = u64::from_be_bytes(arr);
                        }
                        Err(e) => {
                            log::error!("couldn't convert ivec to u64: {:?}", e);
                            last_group = 0;
                        }
                    }
                }
                None => {
                    last_group = 0;
                }
                Some(Err(e)) => {
                    log::error!("Sled group table error: {}", e);
                    last_group = 0;
                }
            }

            let mut ids: BTreeMap<Vec<u8>, u64> = BTreeMap::new();

            //initialize group_id mapping
            for res in tree.iter() {
                match res {
                    Ok((idx, group)) => {
                        let index = idx.to_vec();
                        ids.insert(group.id, u64::from_be_bytes(index.try_into().unwrap()));
                    }
                    Err(e) => {
                        log::error!("Error retrieving feed message from data base: {}", e);
                    }
                }
            }

            let groups = Groups {
                groups: tree,
                invited: invited,
                last_group,
                group_ids: ids,
            };
            groups
        }
    */
    /// Send packed notify message directly
    pub fn send_notify_message(user_account: &UserAccount, receiver: &PeerId, data: Vec<u8>) {
        // pack group container into messaging message
        let proto_message = proto::Messaging {
            message: Some(proto::messaging::Message::GroupInviteMessage(
                proto::GroupInviteMessage { content: data },
            )),
        };

        // send message via messaging
        let message_id: Vec<u8> = Vec::new();
        match Messaging::pack_and_send_message(
            user_account,
            &receiver,
            proto_message.encode_to_vec(),
            MessagingServiceType::Group,
            &message_id,
            true,
        ) {
            Ok(_) => {}
            Err(err) => {
                log::error!("group notify message sending failed {}", err);
            }
        }
    }

    /// Send capsuled group message through messaging service
    pub fn send_group_message(
        user_account: &UserAccount,
        receiver: &PeerId,
        group_id: Vec<u8>,
        data: &Vec<u8>,
    ) {
        // get last index
        let group;
        match GroupStorage::get_group(user_account.id, group_id.clone()) {
            Some(v) => group = v,
            None => return,
        }

        let mut my_member;
        match group.get_member(&user_account.id.to_bytes()) {
            Some(v) => {
                my_member = v.clone();
            }
            _ => {
                return;
            }
        }

        let last_index = my_member.last_message_index + 1;
        let message_id = Chat::generate_message_id(&group.id, &user_account.id, last_index);
        let common_message = proto::CommonMessage {
            message_id: message_id.clone(),
            conversation_id: group.id.clone(),
            sent_at: timestamp::Timestamp::get_timestamp(),
            payload: Some(proto::common_message::Payload::GroupMessage(
                proto::GroupMessage {
                    content: data.clone(),
                },
            )),
        };

        let send_message = proto::Messaging {
            message: Some(proto::messaging::Message::CommonMessage(
                common_message.clone(),
            )),
        };

        // send message via messaging
        match Messaging::pack_and_send_message(
            user_account,
            &receiver,
            send_message.encode_to_vec(),
            MessagingServiceType::Group,
            &message_id,
            true,
        ) {
            Ok(_) => {
                // save
                // ChatStorage::save_outgoing_message(
                //     &user_account.id,
                //     &receiver,
                //     &group_id,
                //     &message_id,
                //     chat::rpc_proto::ChatContentType::Group.try_into().unwrap(),
                //     data,
                //     chat::rpc_proto::MessageStatus::Sending,
                // );

                // update member state
                my_member.last_message_index = last_index;
                Self::update_group_member(&user_account.id, &group_id, &my_member);
            }
            Err(err) => {
                log::error!("group message sending failed {}", err);
            }
        }
    }

    /// Send group updated to all members
    fn post_group_update(account_id: &PeerId, group_id: &Vec<u8>) {
        let group;
        match GroupStorage::get_group(account_id.to_owned(), group_id.to_owned()) {
            Some(my_group) => group = my_group,
            None => return,
        }

        // create group notify message and post to all members
        let mut members: Vec<proto_net::GroupMember> = vec![];
        for m in group.members.values() {
            if m.state > 0 {
                members.push(proto_net::GroupMember {
                    user_id: m.user_id.clone(),
                    role: m.role,
                    state: m.state,
                    joined_at: m.joined_at,
                    last_message_index: m.last_message_index,
                });
            }
        }

        let notify = proto_net::GroupInfo {
            group_id: group_id.clone(),
            group_name: group.name.clone(),
            created_at: group.created_at,
            revision: group.revision,
            members,
        };

        let container = proto_net::GroupContainer {
            message: Some(proto_net::group_container::Message::GroupInfo(notify)),
        };

        let send_message = proto::Messaging {
            message: Some(proto::messaging::Message::GroupInviteMessage(
                proto::GroupInviteMessage {
                    content: container.encode_to_vec(),
                },
            )),
        };

        // send to all group members
        if let Some(user_account) = UserAccounts::get_by_id(*account_id) {
            for user_id in group.members.keys() {
                let receiver = PeerId::from_bytes(&user_id.clone()).unwrap();
                if receiver != *account_id {
                    let message_id: Vec<u8> = Vec::new();
                    if let Err(error) = Messaging::pack_and_send_message(
                        &user_account,
                        &receiver,
                        send_message.encode_to_vec(),
                        MessagingServiceType::Group,
                        &message_id,
                        true,
                    ) {
                        log::error!("send group notify error {}", error);
                    }
                }
            }
        }
    }

    /// Process group info message from network
    pub fn on_notify(sender_id: &PeerId, receiver_id: &PeerId, data: &Vec<u8>) {
        match proto_net::GroupInfo::decode(&data[..]) {
            Ok(notify) => {
                manage::Manage::on_group_notify(
                    sender_id.to_owned(),
                    receiver_id.to_owned(),
                    &notify,
                );
            }
            _ => {
                log::error!("invalid group notify message");
            }
        }
    }

    /// Process incoming NET messages for group chat module
    pub fn net(sender_id: &PeerId, receiver_id: &PeerId, data: &Vec<u8>) {
        // check receiver id is in users list
        let user;
        match UserAccounts::get_by_id(receiver_id.clone()) {
            Some(usr) => {
                user = usr;
            }
            None => {
                log::error!("no user id={}", receiver_id);
                return;
            }
        }

        match proto_net::GroupContainer::decode(&data[..]) {
            Ok(messaging) => match messaging.message {
                Some(proto_net::group_container::Message::InviteMember(invite_member)) => {
                    log::info!("group::on_receive_invite");
                    Member::on_be_invited(&sender_id, &receiver_id, &invite_member);
                }
                Some(proto_net::group_container::Message::Removed(_removed)) => {
                    log::info!("group::on_removed");
                }
                Some(proto_net::group_container::Message::ReplyInvite(reply_invite)) => {
                    log::info!("group::on_answered for invite");
                    if let Err(error) =
                        Member::on_reply_invite(sender_id, receiver_id, &reply_invite)
                    {
                        log::error!("group on_reply_invite error {}", error);
                    } else {
                        if reply_invite.accept {
                            Self::post_group_update(&user.id, &reply_invite.group_id);
                        }
                    }
                }
                Some(proto_net::group_container::Message::GroupInfo(group_info)) => {
                    log::info!("group info arrived");
                    manage::Manage::on_group_notify(
                        sender_id.to_owned(),
                        receiver_id.to_owned(),
                        &group_info,
                    );
                }
                None => {
                    log::error!("group message from {} was empty", sender_id.to_base58())
                }
            },
            Err(e) => {
                log::error!(
                    "Error decoding Group Message from {} to {}: {}",
                    sender_id.to_base58(),
                    receiver_id.to_base58(),
                    e
                );
            }
        }
    }

    /// Process incoming RPC request messages for group chat module
    pub fn rpc(data: Vec<u8>, user_id: Vec<u8>) {
        let my_user_id = PeerId::from_bytes(&user_id).unwrap();

        match proto_rpc::Group::decode(&data[..]) {
            Ok(group) => {
                match group.message {
                    Some(proto_rpc::group::Message::GroupCreateRequest(group_create_req)) => {
                        let id = Manage::create_new_group(
                            &my_user_id,
                            group_create_req.group_name.clone(),
                        );
                        //make response
                        let proto_message = proto_rpc::Group {
                            message: Some(proto_rpc::group::Message::GroupCreateResponse(
                                proto_rpc::GroupCreateResponse {
                                    group_id: id,
                                    result: Some(proto_rpc::GroupResult {
                                        status: true,
                                        message: "".to_string(),
                                    }),
                                },
                            )),
                        };

                        // send message
                        Rpc::send_message(
                            proto_message.encode_to_vec(),
                            crate::rpc::proto::Modules::Group.into(),
                            "".to_string(),
                            Vec::new(),
                        );
                    }
                    Some(proto_rpc::group::Message::GroupRenameRequest(group_rename_req)) => {
                        let mut status = true;
                        let mut message: String = "".to_string();
                        if let Err(err) = Manage::rename_group(
                            &my_user_id,
                            &group_rename_req.group_id,
                            group_rename_req.group_name.clone(),
                        ) {
                            status = false;
                            message = err.clone();
                        }

                        let proto_message = proto_rpc::Group {
                            message: Some(proto_rpc::group::Message::GroupRenameResponse(
                                proto_rpc::GroupRenameResponse {
                                    group_id: group_rename_req.group_id.clone(),
                                    group_name: group_rename_req.group_name.clone(),
                                    result: Some(proto_rpc::GroupResult { status, message }),
                                },
                            )),
                        };

                        // send message
                        Rpc::send_message(
                            proto_message.encode_to_vec(),
                            crate::rpc::proto::Modules::Group.into(),
                            "".to_string(),
                            Vec::new(),
                        );

                        //post updates
                        if status {
                            Self::post_group_update(&my_user_id, &group_rename_req.group_id);
                        }
                    }
                    Some(proto_rpc::group::Message::GroupInfoRequest(group_info_req)) => {
                        match Manage::group_info(&my_user_id, &group_info_req.group_id) {
                            Ok(res) => {
                                let proto_message = proto_rpc::Group {
                                    message: Some(proto_rpc::group::Message::GroupInfoResponse(
                                        res,
                                    )),
                                };

                                // send message
                                Rpc::send_message(
                                    proto_message.encode_to_vec(),
                                    crate::rpc::proto::Modules::Group.into(),
                                    "".to_string(),
                                    Vec::new(),
                                );
                            }
                            Err(err) => {
                                log::error!("Get group info error, {}", err);
                            }
                        }
                    }
                    Some(proto_rpc::group::Message::GroupListRequest(_group_list_req)) => {
                        let list = Manage::group_list(&my_user_id);
                        let proto_message = proto_rpc::Group {
                            message: Some(proto_rpc::group::Message::GroupListResponse(list)),
                        };
                        // send message
                        Rpc::send_message(
                            proto_message.encode_to_vec(),
                            crate::rpc::proto::Modules::Group.into(),
                            "".to_string(),
                            Vec::new(),
                        );
                    }
                    Some(proto_rpc::group::Message::GroupInvitedRequest(_group_invited_req)) => {
                        let invited = Manage::invited_list(&my_user_id);
                        let proto_message = proto_rpc::Group {
                            message: Some(proto_rpc::group::Message::GroupInvitedResponse(invited)),
                        };
                        // send message
                        Rpc::send_message(
                            proto_message.encode_to_vec(),
                            crate::rpc::proto::Modules::Group.into(),
                            "".to_string(),
                            Vec::new(),
                        );
                    }
                    Some(proto_rpc::group::Message::GroupInviteMemberRequest(invite_req)) => {
                        let mut status = true;
                        let mut message: String = "".to_string();
                        if let Err(err) = Member::invite(
                            &my_user_id,
                            &invite_req.group_id,
                            &PeerId::from_bytes(&invite_req.user_id).unwrap(),
                        ) {
                            status = false;
                            message = err.clone();
                            log::error!("Get group info error, {}", err);
                        }
                        let proto_message = proto_rpc::Group {
                            message: Some(proto_rpc::group::Message::GroupInviteMemberResponse(
                                proto_rpc::GroupInviteMemberResponse {
                                    group_id: invite_req.group_id.clone(),
                                    user_id: invite_req.user_id.clone(),
                                    result: Some(proto_rpc::GroupResult { status, message }),
                                },
                            )),
                        };

                        // send message
                        Rpc::send_message(
                            proto_message.encode_to_vec(),
                            crate::rpc::proto::Modules::Group.into(),
                            "".to_string(),
                            Vec::new(),
                        );
                    }
                    Some(proto_rpc::group::Message::GroupReplyInviteRequest(reply_req)) => {
                        let mut status = true;
                        let mut message: String = "".to_string();

                        if let Err(err) =
                            Member::reply_invite(&my_user_id, &reply_req.group_id, reply_req.accept)
                        {
                            status = false;
                            message = err.clone();
                            log::error!("Get group info error, {}", err);
                        }
                        let proto_message = proto_rpc::Group {
                            message: Some(proto_rpc::group::Message::GroupReplyInviteResponse(
                                proto_rpc::GroupReplyInviteResponse {
                                    group_id: reply_req.group_id.clone(),
                                    result: Some(proto_rpc::GroupResult { status, message }),
                                },
                            )),
                        };

                        // send message
                        Rpc::send_message(
                            proto_message.encode_to_vec(),
                            crate::rpc::proto::Modules::Group.into(),
                            "".to_string(),
                            Vec::new(),
                        );
                    }
                    Some(proto_rpc::group::Message::GroupRemoveMemberRequest(remove_req)) => {
                        let mut status = true;
                        let mut message: String = "".to_string();

                        if let Err(err) = Member::remove(
                            &my_user_id,
                            &remove_req.group_id,
                            &PeerId::from_bytes(&remove_req.user_id).unwrap(),
                        ) {
                            status = false;
                            message = err.clone();
                            log::error!("Get group info error, {}", err);
                        }

                        let proto_message = proto_rpc::Group {
                            message: Some(proto_rpc::group::Message::GroupRemoveMemberResponse(
                                proto_rpc::GroupRemoveMemberResponse {
                                    group_id: remove_req.group_id.clone(),
                                    user_id: remove_req.user_id.clone(),
                                    result: Some(proto_rpc::GroupResult { status, message }),
                                },
                            )),
                        };

                        // send message
                        Rpc::send_message(
                            proto_message.encode_to_vec(),
                            crate::rpc::proto::Modules::Group.into(),
                            "".to_string(),
                            Vec::new(),
                        );

                        if status {
                            Self::post_group_update(&my_user_id, &remove_req.group_id);
                        }
                    }
                    _ => {
                        log::error!("Unhandled Protobuf Group chat message");
                    }
                }
            }
            Err(error) => {
                log::error!("{:?}", error);
            }
        }
    }
}
