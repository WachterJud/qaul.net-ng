// Copyright (c) 2022 Open Community Project Association https://ocpa.ch
// This software is published under the AGPLv3 license.

//! # Qaul Group Service
//!
//! The Group service manages groups and their members.
//! 
//! The Group messages are carried on the Messaging service:
//! Messaging(Group(GroupContainer(...)))



use libp2p::{
    PeerId,
};

use prost::Message;
use state::Storage;
use std::collections::BTreeMap;
use std::{
    sync::RwLock,
};
use crate::node::user_accounts::{UserAccount, UserAccounts};
use crate::rpc::Rpc;

use super::messaging::proto;
use super::messaging::Messaging;
use crate::utilities::timestamp;

mod rtc_managing;
use rtc_managing::RtcManaging;

mod rtc_messaging;
use rtc_messaging::RtcMessaging;


/// Import protobuf message definition generated by
/// the rust module prost-build.
pub mod proto_rpc {
    include!("qaul.rpc.rtc.rs");
}
pub mod proto_net {
    include!("qaul.net.rtc.rs");
}

// Structure of rtc session
#[derive(Clone)]
pub struct RtcSession {
    // user id 
    pub user_id: Vec<u8>,
    // conversation id
    pub conversation_id: Vec<u8>,
    // session type
    pub session_type: u32,    
    // created at    
    pub created_at: u64,
    // state 1: sent req, 2:received req, 3: established
    pub state: u8,    
}

/// Structure to management for sessions.
#[derive(Clone)]
pub struct RtcSessions {
    // id mapping conversation id => session
    pub sessions: BTreeMap<Vec<u8>, RtcSession>,
}


/// mutable state of all user groups
pub static RTCSESSIONS: Storage<RwLock<RtcSessions>> = Storage::new();

pub struct Rtc{
}

/// Group module to process transfer, receive and RPC commands
impl Rtc {
    /// initialize group chat module
    pub fn init() {
        let rtc_sessions = RtcSessions{
            sessions: BTreeMap::new(),
        };
        RTCSESSIONS.set(RwLock::new(rtc_sessions));
    }


    /// get session from session_id
    pub fn get_session_from_id(converssation_id: &Vec<u8>) ->Option<RtcSession> {   
        let sessions = RTCSESSIONS.get().read().unwrap();
        if sessions.sessions.contains_key(converssation_id) {            
            return Some(sessions.sessions.get(converssation_id).unwrap().clone());
        }
        None
    }

    /// get session from session_id
    pub fn update_session(session: RtcSession){   
        let mut sessions = RTCSESSIONS.get().write().unwrap();
        sessions.sessions.insert(session.conversation_id.clone(), session);
    }

    /// remove session on the storage
    pub fn remove_session(session_id: &Vec<u8>){   
        let mut sessions = RTCSESSIONS.get().write().unwrap();
        sessions.sessions.remove(session_id);
    }  

    /// Send capsuled group message through messaging service
    pub fn send_rtc_message_through_message(user_account: &UserAccount, receiver:PeerId, data: &Vec<u8>){
        let message_id = Messaging::generate_message_id(&user_account.id);
        let send_message = proto::CommonMessage{
            message_id: message_id.clone(),
            conversation_id: vec![],
            sent_at: timestamp::Timestamp::get_timestamp(),            
            payload: Some(proto::common_message::Payload::RtcMessage(
                proto::RtcMessage {
                    content: data.clone(),
                }
            )),
        };

        let mut message_buf00 = Vec::with_capacity(send_message.encoded_len());
        send_message
            .encode(&mut message_buf00)
            .expect("Vec<u8> provides capacity as needed");
        log::info!("message_buf len {}", message_buf00.len());

        // send message via messaging
        if let Err(e) = Messaging::pack_and_send_message(user_account, &receiver, &message_buf00, Some(&message_id), true) {
            log::error!("rtc message sending failed {}", e.to_string());
        }
    }

    /// Process incoming NET messages for rtc module
    pub fn net(sender_id: PeerId, receiver_id: PeerId, data: Vec<u8>, signature: Vec<u8>){
        //check receiver id is in users list
        match UserAccounts::get_by_id(receiver_id) {
            None => {
                log::error!("no user id={}", receiver_id);
                return;
            },
            _ => {}
        }

        match proto_net::RtcContainer::decode(&data[..]) {
            Ok(messaging) =>{
                match messaging.message{
                    Some(proto_net::rtc_container::Message::RtcSessionRequest(session_req)) => {
                        log::error!("on_session_request");
                        rtc_managing::RtcManaging::on_session_request(&sender_id, &receiver_id, &session_req, signature);
                    },
                    Some(proto_net::rtc_container::Message::RtcSessionManagement(session_mgr)) => {
                        log::error!("on_session_management");
                        rtc_managing::RtcManaging::on_session_management(&sender_id, &receiver_id, &session_mgr, signature);
                    },
                    Some(proto_net::rtc_container::Message::RtcMessage(message)) => {
                        log::error!("on_session_message");
                        rtc_messaging::RtcMessaging::on_message(&sender_id, &receiver_id, &message, signature);
                    },
                    None => {
                        log::error!("rtc message from {} was empty", sender_id.to_base58())
                    },                    
                }
            },
            Err(e) => {
                log::error!(
                    "Error decoding Rtc Message from {} to {}: {}",
                    sender_id.to_base58(),
                    receiver_id.to_base58(),
                    e
                );
            }
        }

    }

    /// Process incoming RPC request messages for group chat module
    pub fn rpc(data: Vec<u8>, user_id: Vec<u8>) {
        let my_user_id = PeerId::from_bytes(&user_id).unwrap();

        match proto_rpc::RtcRpc::decode(&data[..]) {
            Ok(rtc_rpc) => {
                match rtc_rpc.message {
                    Some(proto_rpc::rtc_rpc::Message::RtcSessionRequest(session_req)) => {

                        match RtcManaging::session_request(&my_user_id, &session_req){
                            Err(error) =>{
                                log::error!("rtc request error {}", error);
                            },
                            Ok(_id) => {
                                //make response
                                let proto_message = proto_rpc::RtcRpc {
                                    message: Some(proto_rpc::rtc_rpc::Message::RtcSessionResponse(
                                        proto_rpc::RtcSessionResponse {
                                            conversation_id: session_req.conversation_id.clone(),
                                        },
                                    )),
                                };

                                // encode message
                                let mut buf = Vec::with_capacity(proto_message.encoded_len());
                                proto_message
                                    .encode(&mut buf)
                                    .expect("Vec<u8> provides capacity as needed");

                                // send message
                                Rpc::send_message(
                                    buf,
                                    crate::rpc::proto::Modules::Rtc.into(),
                                    "".to_string(),
                                    Vec::new(),
                                );
                            }
                        }
                        
                    },
                    Some(proto_rpc::rtc_rpc::Message::RtcSessionManagement(session_req)) => {
                        if let Err(error) = RtcManaging::session_management(&my_user_id, &session_req){
                            log::error!("rtc management error {}", error);
                        }
                    },           
                    Some(proto_rpc::rtc_rpc::Message::RtcOutgoing(session_req)) => {
                        if let Err(error) = RtcMessaging::send_message(&my_user_id, &session_req){
                            log::error!("rtc message error {}", error);
                        }
                    },
                    Some(proto_rpc::rtc_rpc::Message::RtcSessionListRequest(_session_req)) => {
                        let res = RtcManaging::session_list(&my_user_id);
                        //make response
                        let proto_message = proto_rpc::RtcRpc {
                            message: Some(proto_rpc::rtc_rpc::Message::RtcSessionListResponse(
                                res
                            )),
                        };

                        // encode message
                        let mut buf = Vec::with_capacity(proto_message.encoded_len());
                        proto_message
                            .encode(&mut buf)
                            .expect("Vec<u8> provides capacity as needed");

                        // send message
                        Rpc::send_message(
                            buf,
                            crate::rpc::proto::Modules::Rtc.into(),
                            "".to_string(),
                            Vec::new(),
                        );

                    },
                  
                    _ => {
                        log::error!("Unhandled Protobuf RTC message");
                    }
                }
            }
            Err(error) => {
                log::error!("{:?}", error);
            }
        }
    }

}
