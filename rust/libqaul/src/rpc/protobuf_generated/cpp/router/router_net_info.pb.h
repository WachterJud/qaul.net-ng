// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: router/router_net_info.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_router_2frouter_5fnet_5finfo_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_router_2frouter_5fnet_5finfo_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_router_2frouter_5fnet_5finfo_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_router_2frouter_5fnet_5finfo_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_router_2frouter_5fnet_5finfo_2eproto;
namespace qaul {
namespace net {
namespace router_net_info {
class RouterInfoContainer;
struct RouterInfoContainerDefaultTypeInternal;
extern RouterInfoContainerDefaultTypeInternal _RouterInfoContainer_default_instance_;
class RouterInfoContent;
struct RouterInfoContentDefaultTypeInternal;
extern RouterInfoContentDefaultTypeInternal _RouterInfoContent_default_instance_;
class RouterInfoMessage;
struct RouterInfoMessageDefaultTypeInternal;
extern RouterInfoMessageDefaultTypeInternal _RouterInfoMessage_default_instance_;
class Routing;
struct RoutingDefaultTypeInternal;
extern RoutingDefaultTypeInternal _Routing_default_instance_;
class RoutingInfoEntry;
struct RoutingInfoEntryDefaultTypeInternal;
extern RoutingInfoEntryDefaultTypeInternal _RoutingInfoEntry_default_instance_;
class RoutingInfoTable;
struct RoutingInfoTableDefaultTypeInternal;
extern RoutingInfoTableDefaultTypeInternal _RoutingInfoTable_default_instance_;
class UserInfo;
struct UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
class UserInfoTable;
struct UserInfoTableDefaultTypeInternal;
extern UserInfoTableDefaultTypeInternal _UserInfoTable_default_instance_;
}  // namespace router_net_info
}  // namespace net
}  // namespace qaul
PROTOBUF_NAMESPACE_OPEN
template<> ::qaul::net::router_net_info::RouterInfoContainer* Arena::CreateMaybeMessage<::qaul::net::router_net_info::RouterInfoContainer>(Arena*);
template<> ::qaul::net::router_net_info::RouterInfoContent* Arena::CreateMaybeMessage<::qaul::net::router_net_info::RouterInfoContent>(Arena*);
template<> ::qaul::net::router_net_info::RouterInfoMessage* Arena::CreateMaybeMessage<::qaul::net::router_net_info::RouterInfoMessage>(Arena*);
template<> ::qaul::net::router_net_info::Routing* Arena::CreateMaybeMessage<::qaul::net::router_net_info::Routing>(Arena*);
template<> ::qaul::net::router_net_info::RoutingInfoEntry* Arena::CreateMaybeMessage<::qaul::net::router_net_info::RoutingInfoEntry>(Arena*);
template<> ::qaul::net::router_net_info::RoutingInfoTable* Arena::CreateMaybeMessage<::qaul::net::router_net_info::RoutingInfoTable>(Arena*);
template<> ::qaul::net::router_net_info::UserInfo* Arena::CreateMaybeMessage<::qaul::net::router_net_info::UserInfo>(Arena*);
template<> ::qaul::net::router_net_info::UserInfoTable* Arena::CreateMaybeMessage<::qaul::net::router_net_info::UserInfoTable>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace qaul {
namespace net {
namespace router_net_info {

// ===================================================================

class RouterInfoContainer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.net.router_net_info.RouterInfoContainer) */ {
 public:
  inline RouterInfoContainer() : RouterInfoContainer(nullptr) {}
  ~RouterInfoContainer() override;
  explicit constexpr RouterInfoContainer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouterInfoContainer(const RouterInfoContainer& from);
  RouterInfoContainer(RouterInfoContainer&& from) noexcept
    : RouterInfoContainer() {
    *this = ::std::move(from);
  }

  inline RouterInfoContainer& operator=(const RouterInfoContainer& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterInfoContainer& operator=(RouterInfoContainer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterInfoContainer& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterInfoContainer* internal_default_instance() {
    return reinterpret_cast<const RouterInfoContainer*>(
               &_RouterInfoContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RouterInfoContainer& a, RouterInfoContainer& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterInfoContainer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterInfoContainer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterInfoContainer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterInfoContainer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouterInfoContainer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouterInfoContainer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouterInfoContainer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.net.router_net_info.RouterInfoContainer";
  }
  protected:
  explicit RouterInfoContainer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // bytes signature = 1;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // bytes message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:qaul.net.router_net_info.RouterInfoContainer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2frouter_5fnet_5finfo_2eproto;
};
// -------------------------------------------------------------------

class RouterInfoContent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.net.router_net_info.RouterInfoContent) */ {
 public:
  inline RouterInfoContent() : RouterInfoContent(nullptr) {}
  ~RouterInfoContent() override;
  explicit constexpr RouterInfoContent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouterInfoContent(const RouterInfoContent& from);
  RouterInfoContent(RouterInfoContent&& from) noexcept
    : RouterInfoContent() {
    *this = ::std::move(from);
  }

  inline RouterInfoContent& operator=(const RouterInfoContent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterInfoContent& operator=(RouterInfoContent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterInfoContent& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterInfoContent* internal_default_instance() {
    return reinterpret_cast<const RouterInfoContent*>(
               &_RouterInfoContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RouterInfoContent& a, RouterInfoContent& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterInfoContent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterInfoContent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterInfoContent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterInfoContent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouterInfoContent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouterInfoContent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouterInfoContent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.net.router_net_info.RouterInfoContent";
  }
  protected:
  explicit RouterInfoContent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kContentFieldNumber = 2,
    kTimeFieldNumber = 3,
  };
  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bytes content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // uint64 time = 3;
  void clear_time();
  uint64_t time() const;
  void set_time(uint64_t value);
  private:
  uint64_t _internal_time() const;
  void _internal_set_time(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:qaul.net.router_net_info.RouterInfoContent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  uint64_t time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2frouter_5fnet_5finfo_2eproto;
};
// -------------------------------------------------------------------

class RouterInfoMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.net.router_net_info.RouterInfoMessage) */ {
 public:
  inline RouterInfoMessage() : RouterInfoMessage(nullptr) {}
  ~RouterInfoMessage() override;
  explicit constexpr RouterInfoMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouterInfoMessage(const RouterInfoMessage& from);
  RouterInfoMessage(RouterInfoMessage&& from) noexcept
    : RouterInfoMessage() {
    *this = ::std::move(from);
  }

  inline RouterInfoMessage& operator=(const RouterInfoMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouterInfoMessage& operator=(RouterInfoMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouterInfoMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouterInfoMessage* internal_default_instance() {
    return reinterpret_cast<const RouterInfoMessage*>(
               &_RouterInfoMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RouterInfoMessage& a, RouterInfoMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RouterInfoMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouterInfoMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouterInfoMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouterInfoMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouterInfoMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouterInfoMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouterInfoMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.net.router_net_info.RouterInfoMessage";
  }
  protected:
  explicit RouterInfoMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeFieldNumber = 1,
    kRoutesFieldNumber = 2,
    kUsersFieldNumber = 3,
    kTimestampFieldNumber = 4,
  };
  // bytes node = 1;
  void clear_node();
  const std::string& node() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node();
  PROTOBUF_NODISCARD std::string* release_node();
  void set_allocated_node(std::string* node);
  private:
  const std::string& _internal_node() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node(const std::string& value);
  std::string* _internal_mutable_node();
  public:

  // .qaul.net.router_net_info.RoutingInfoTable routes = 2;
  bool has_routes() const;
  private:
  bool _internal_has_routes() const;
  public:
  void clear_routes();
  const ::qaul::net::router_net_info::RoutingInfoTable& routes() const;
  PROTOBUF_NODISCARD ::qaul::net::router_net_info::RoutingInfoTable* release_routes();
  ::qaul::net::router_net_info::RoutingInfoTable* mutable_routes();
  void set_allocated_routes(::qaul::net::router_net_info::RoutingInfoTable* routes);
  private:
  const ::qaul::net::router_net_info::RoutingInfoTable& _internal_routes() const;
  ::qaul::net::router_net_info::RoutingInfoTable* _internal_mutable_routes();
  public:
  void unsafe_arena_set_allocated_routes(
      ::qaul::net::router_net_info::RoutingInfoTable* routes);
  ::qaul::net::router_net_info::RoutingInfoTable* unsafe_arena_release_routes();

  // .qaul.net.router_net_info.UserInfoTable users = 3;
  bool has_users() const;
  private:
  bool _internal_has_users() const;
  public:
  void clear_users();
  const ::qaul::net::router_net_info::UserInfoTable& users() const;
  PROTOBUF_NODISCARD ::qaul::net::router_net_info::UserInfoTable* release_users();
  ::qaul::net::router_net_info::UserInfoTable* mutable_users();
  void set_allocated_users(::qaul::net::router_net_info::UserInfoTable* users);
  private:
  const ::qaul::net::router_net_info::UserInfoTable& _internal_users() const;
  ::qaul::net::router_net_info::UserInfoTable* _internal_mutable_users();
  public:
  void unsafe_arena_set_allocated_users(
      ::qaul::net::router_net_info::UserInfoTable* users);
  ::qaul::net::router_net_info::UserInfoTable* unsafe_arena_release_users();

  // uint64 timestamp = 4;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:qaul.net.router_net_info.RouterInfoMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_;
  ::qaul::net::router_net_info::RoutingInfoTable* routes_;
  ::qaul::net::router_net_info::UserInfoTable* users_;
  uint64_t timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2frouter_5fnet_5finfo_2eproto;
};
// -------------------------------------------------------------------

class Routing final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.net.router_net_info.Routing) */ {
 public:
  inline Routing() : Routing(nullptr) {}
  ~Routing() override;
  explicit constexpr Routing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Routing(const Routing& from);
  Routing(Routing&& from) noexcept
    : Routing() {
    *this = ::std::move(from);
  }

  inline Routing& operator=(const Routing& from) {
    CopyFrom(from);
    return *this;
  }
  inline Routing& operator=(Routing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Routing& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kUserInfoTable = 1,
    kUserInfo = 2,
    kRoutingInfoTable = 3,
    kRoutingInfoEntry = 4,
    MESSAGE_NOT_SET = 0,
  };

  static inline const Routing* internal_default_instance() {
    return reinterpret_cast<const Routing*>(
               &_Routing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Routing& a, Routing& b) {
    a.Swap(&b);
  }
  inline void Swap(Routing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Routing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Routing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Routing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Routing& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Routing& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Routing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.net.router_net_info.Routing";
  }
  protected:
  explicit Routing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserInfoTableFieldNumber = 1,
    kUserInfoFieldNumber = 2,
    kRoutingInfoTableFieldNumber = 3,
    kRoutingInfoEntryFieldNumber = 4,
  };
  // .qaul.net.router_net_info.UserInfoTable user_info_table = 1;
  bool has_user_info_table() const;
  private:
  bool _internal_has_user_info_table() const;
  public:
  void clear_user_info_table();
  const ::qaul::net::router_net_info::UserInfoTable& user_info_table() const;
  PROTOBUF_NODISCARD ::qaul::net::router_net_info::UserInfoTable* release_user_info_table();
  ::qaul::net::router_net_info::UserInfoTable* mutable_user_info_table();
  void set_allocated_user_info_table(::qaul::net::router_net_info::UserInfoTable* user_info_table);
  private:
  const ::qaul::net::router_net_info::UserInfoTable& _internal_user_info_table() const;
  ::qaul::net::router_net_info::UserInfoTable* _internal_mutable_user_info_table();
  public:
  void unsafe_arena_set_allocated_user_info_table(
      ::qaul::net::router_net_info::UserInfoTable* user_info_table);
  ::qaul::net::router_net_info::UserInfoTable* unsafe_arena_release_user_info_table();

  // .qaul.net.router_net_info.UserInfo user_info = 2;
  bool has_user_info() const;
  private:
  bool _internal_has_user_info() const;
  public:
  void clear_user_info();
  const ::qaul::net::router_net_info::UserInfo& user_info() const;
  PROTOBUF_NODISCARD ::qaul::net::router_net_info::UserInfo* release_user_info();
  ::qaul::net::router_net_info::UserInfo* mutable_user_info();
  void set_allocated_user_info(::qaul::net::router_net_info::UserInfo* user_info);
  private:
  const ::qaul::net::router_net_info::UserInfo& _internal_user_info() const;
  ::qaul::net::router_net_info::UserInfo* _internal_mutable_user_info();
  public:
  void unsafe_arena_set_allocated_user_info(
      ::qaul::net::router_net_info::UserInfo* user_info);
  ::qaul::net::router_net_info::UserInfo* unsafe_arena_release_user_info();

  // .qaul.net.router_net_info.RoutingInfoTable routing_info_table = 3;
  bool has_routing_info_table() const;
  private:
  bool _internal_has_routing_info_table() const;
  public:
  void clear_routing_info_table();
  const ::qaul::net::router_net_info::RoutingInfoTable& routing_info_table() const;
  PROTOBUF_NODISCARD ::qaul::net::router_net_info::RoutingInfoTable* release_routing_info_table();
  ::qaul::net::router_net_info::RoutingInfoTable* mutable_routing_info_table();
  void set_allocated_routing_info_table(::qaul::net::router_net_info::RoutingInfoTable* routing_info_table);
  private:
  const ::qaul::net::router_net_info::RoutingInfoTable& _internal_routing_info_table() const;
  ::qaul::net::router_net_info::RoutingInfoTable* _internal_mutable_routing_info_table();
  public:
  void unsafe_arena_set_allocated_routing_info_table(
      ::qaul::net::router_net_info::RoutingInfoTable* routing_info_table);
  ::qaul::net::router_net_info::RoutingInfoTable* unsafe_arena_release_routing_info_table();

  // .qaul.net.router_net_info.RoutingInfoEntry routing_info_entry = 4;
  bool has_routing_info_entry() const;
  private:
  bool _internal_has_routing_info_entry() const;
  public:
  void clear_routing_info_entry();
  const ::qaul::net::router_net_info::RoutingInfoEntry& routing_info_entry() const;
  PROTOBUF_NODISCARD ::qaul::net::router_net_info::RoutingInfoEntry* release_routing_info_entry();
  ::qaul::net::router_net_info::RoutingInfoEntry* mutable_routing_info_entry();
  void set_allocated_routing_info_entry(::qaul::net::router_net_info::RoutingInfoEntry* routing_info_entry);
  private:
  const ::qaul::net::router_net_info::RoutingInfoEntry& _internal_routing_info_entry() const;
  ::qaul::net::router_net_info::RoutingInfoEntry* _internal_mutable_routing_info_entry();
  public:
  void unsafe_arena_set_allocated_routing_info_entry(
      ::qaul::net::router_net_info::RoutingInfoEntry* routing_info_entry);
  ::qaul::net::router_net_info::RoutingInfoEntry* unsafe_arena_release_routing_info_entry();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:qaul.net.router_net_info.Routing)
 private:
  class _Internal;
  void set_has_user_info_table();
  void set_has_user_info();
  void set_has_routing_info_table();
  void set_has_routing_info_entry();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union MessageUnion {
    constexpr MessageUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::qaul::net::router_net_info::UserInfoTable* user_info_table_;
    ::qaul::net::router_net_info::UserInfo* user_info_;
    ::qaul::net::router_net_info::RoutingInfoTable* routing_info_table_;
    ::qaul::net::router_net_info::RoutingInfoEntry* routing_info_entry_;
  } message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_router_2frouter_5fnet_5finfo_2eproto;
};
// -------------------------------------------------------------------

class RoutingInfoTable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.net.router_net_info.RoutingInfoTable) */ {
 public:
  inline RoutingInfoTable() : RoutingInfoTable(nullptr) {}
  ~RoutingInfoTable() override;
  explicit constexpr RoutingInfoTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoutingInfoTable(const RoutingInfoTable& from);
  RoutingInfoTable(RoutingInfoTable&& from) noexcept
    : RoutingInfoTable() {
    *this = ::std::move(from);
  }

  inline RoutingInfoTable& operator=(const RoutingInfoTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutingInfoTable& operator=(RoutingInfoTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutingInfoTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutingInfoTable* internal_default_instance() {
    return reinterpret_cast<const RoutingInfoTable*>(
               &_RoutingInfoTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RoutingInfoTable& a, RoutingInfoTable& b) {
    a.Swap(&b);
  }
  inline void Swap(RoutingInfoTable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutingInfoTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoutingInfoTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoutingInfoTable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoutingInfoTable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoutingInfoTable& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoutingInfoTable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.net.router_net_info.RoutingInfoTable";
  }
  protected:
  explicit RoutingInfoTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 1,
  };
  // repeated .qaul.net.router_net_info.RoutingInfoEntry entry = 1;
  int entry_size() const;
  private:
  int _internal_entry_size() const;
  public:
  void clear_entry();
  ::qaul::net::router_net_info::RoutingInfoEntry* mutable_entry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::RoutingInfoEntry >*
      mutable_entry();
  private:
  const ::qaul::net::router_net_info::RoutingInfoEntry& _internal_entry(int index) const;
  ::qaul::net::router_net_info::RoutingInfoEntry* _internal_add_entry();
  public:
  const ::qaul::net::router_net_info::RoutingInfoEntry& entry(int index) const;
  ::qaul::net::router_net_info::RoutingInfoEntry* add_entry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::RoutingInfoEntry >&
      entry() const;

  // @@protoc_insertion_point(class_scope:qaul.net.router_net_info.RoutingInfoTable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::RoutingInfoEntry > entry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2frouter_5fnet_5finfo_2eproto;
};
// -------------------------------------------------------------------

class RoutingInfoEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.net.router_net_info.RoutingInfoEntry) */ {
 public:
  inline RoutingInfoEntry() : RoutingInfoEntry(nullptr) {}
  ~RoutingInfoEntry() override;
  explicit constexpr RoutingInfoEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoutingInfoEntry(const RoutingInfoEntry& from);
  RoutingInfoEntry(RoutingInfoEntry&& from) noexcept
    : RoutingInfoEntry() {
    *this = ::std::move(from);
  }

  inline RoutingInfoEntry& operator=(const RoutingInfoEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutingInfoEntry& operator=(RoutingInfoEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutingInfoEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutingInfoEntry* internal_default_instance() {
    return reinterpret_cast<const RoutingInfoEntry*>(
               &_RoutingInfoEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RoutingInfoEntry& a, RoutingInfoEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(RoutingInfoEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutingInfoEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoutingInfoEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoutingInfoEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoutingInfoEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoutingInfoEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoutingInfoEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.net.router_net_info.RoutingInfoEntry";
  }
  protected:
  explicit RoutingInfoEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kHcFieldNumber = 3,
    kRttFieldNumber = 2,
    kPlFieldNumber = 4,
  };
  // bytes user = 1;
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // bytes hc = 3;
  void clear_hc();
  const std::string& hc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hc();
  PROTOBUF_NODISCARD std::string* release_hc();
  void set_allocated_hc(std::string* hc);
  private:
  const std::string& _internal_hc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hc(const std::string& value);
  std::string* _internal_mutable_hc();
  public:

  // uint32 rtt = 2;
  void clear_rtt();
  uint32_t rtt() const;
  void set_rtt(uint32_t value);
  private:
  uint32_t _internal_rtt() const;
  void _internal_set_rtt(uint32_t value);
  public:

  // float pl = 4;
  void clear_pl();
  float pl() const;
  void set_pl(float value);
  private:
  float _internal_pl() const;
  void _internal_set_pl(float value);
  public:

  // @@protoc_insertion_point(class_scope:qaul.net.router_net_info.RoutingInfoEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hc_;
  uint32_t rtt_;
  float pl_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2frouter_5fnet_5finfo_2eproto;
};
// -------------------------------------------------------------------

class UserInfoTable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.net.router_net_info.UserInfoTable) */ {
 public:
  inline UserInfoTable() : UserInfoTable(nullptr) {}
  ~UserInfoTable() override;
  explicit constexpr UserInfoTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserInfoTable(const UserInfoTable& from);
  UserInfoTable(UserInfoTable&& from) noexcept
    : UserInfoTable() {
    *this = ::std::move(from);
  }

  inline UserInfoTable& operator=(const UserInfoTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInfoTable& operator=(UserInfoTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserInfoTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserInfoTable* internal_default_instance() {
    return reinterpret_cast<const UserInfoTable*>(
               &_UserInfoTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UserInfoTable& a, UserInfoTable& b) {
    a.Swap(&b);
  }
  inline void Swap(UserInfoTable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserInfoTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserInfoTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserInfoTable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserInfoTable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserInfoTable& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserInfoTable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.net.router_net_info.UserInfoTable";
  }
  protected:
  explicit UserInfoTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // repeated .qaul.net.router_net_info.UserInfo info = 1;
  int info_size() const;
  private:
  int _internal_info_size() const;
  public:
  void clear_info();
  ::qaul::net::router_net_info::UserInfo* mutable_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::UserInfo >*
      mutable_info();
  private:
  const ::qaul::net::router_net_info::UserInfo& _internal_info(int index) const;
  ::qaul::net::router_net_info::UserInfo* _internal_add_info();
  public:
  const ::qaul::net::router_net_info::UserInfo& info(int index) const;
  ::qaul::net::router_net_info::UserInfo* add_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::UserInfo >&
      info() const;

  // @@protoc_insertion_point(class_scope:qaul.net.router_net_info.UserInfoTable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::UserInfo > info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2frouter_5fnet_5finfo_2eproto;
};
// -------------------------------------------------------------------

class UserInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.net.router_net_info.UserInfo) */ {
 public:
  inline UserInfo() : UserInfo(nullptr) {}
  ~UserInfo() override;
  explicit constexpr UserInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserInfo(const UserInfo& from);
  UserInfo(UserInfo&& from) noexcept
    : UserInfo() {
    *this = ::std::move(from);
  }

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
               &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UserInfo& a, UserInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UserInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.net.router_net_info.UserInfo";
  }
  protected:
  explicit UserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kKeyFieldNumber = 2,
    kNameFieldNumber = 3,
  };
  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:qaul.net.router_net_info.UserInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2frouter_5fnet_5finfo_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RouterInfoContainer

// bytes signature = 1;
inline void RouterInfoContainer::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& RouterInfoContainer::signature() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RouterInfoContainer.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouterInfoContainer::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.RouterInfoContainer.signature)
}
inline std::string* RouterInfoContainer::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.RouterInfoContainer.signature)
  return _s;
}
inline const std::string& RouterInfoContainer::_internal_signature() const {
  return signature_.Get();
}
inline void RouterInfoContainer::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RouterInfoContainer::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RouterInfoContainer::release_signature() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.RouterInfoContainer.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RouterInfoContainer::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.RouterInfoContainer.signature)
}

// bytes message = 2;
inline void RouterInfoContainer::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& RouterInfoContainer::message() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RouterInfoContainer.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouterInfoContainer::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.RouterInfoContainer.message)
}
inline std::string* RouterInfoContainer::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.RouterInfoContainer.message)
  return _s;
}
inline const std::string& RouterInfoContainer::_internal_message() const {
  return message_.Get();
}
inline void RouterInfoContainer::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RouterInfoContainer::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RouterInfoContainer::release_message() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.RouterInfoContainer.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RouterInfoContainer::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.RouterInfoContainer.message)
}

// -------------------------------------------------------------------

// RouterInfoContent

// bytes id = 1;
inline void RouterInfoContent::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& RouterInfoContent::id() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RouterInfoContent.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouterInfoContent::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.RouterInfoContent.id)
}
inline std::string* RouterInfoContent::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.RouterInfoContent.id)
  return _s;
}
inline const std::string& RouterInfoContent::_internal_id() const {
  return id_.Get();
}
inline void RouterInfoContent::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RouterInfoContent::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RouterInfoContent::release_id() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.RouterInfoContent.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RouterInfoContent::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.RouterInfoContent.id)
}

// bytes content = 2;
inline void RouterInfoContent::clear_content() {
  content_.ClearToEmpty();
}
inline const std::string& RouterInfoContent::content() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RouterInfoContent.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouterInfoContent::set_content(ArgT0&& arg0, ArgT... args) {
 
 content_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.RouterInfoContent.content)
}
inline std::string* RouterInfoContent::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.RouterInfoContent.content)
  return _s;
}
inline const std::string& RouterInfoContent::_internal_content() const {
  return content_.Get();
}
inline void RouterInfoContent::_internal_set_content(const std::string& value) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RouterInfoContent::_internal_mutable_content() {
  
  return content_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RouterInfoContent::release_content() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.RouterInfoContent.content)
  return content_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RouterInfoContent::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (content_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.RouterInfoContent.content)
}

// uint64 time = 3;
inline void RouterInfoContent::clear_time() {
  time_ = uint64_t{0u};
}
inline uint64_t RouterInfoContent::_internal_time() const {
  return time_;
}
inline uint64_t RouterInfoContent::time() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RouterInfoContent.time)
  return _internal_time();
}
inline void RouterInfoContent::_internal_set_time(uint64_t value) {
  
  time_ = value;
}
inline void RouterInfoContent::set_time(uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.RouterInfoContent.time)
}

// -------------------------------------------------------------------

// RouterInfoMessage

// bytes node = 1;
inline void RouterInfoMessage::clear_node() {
  node_.ClearToEmpty();
}
inline const std::string& RouterInfoMessage::node() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RouterInfoMessage.node)
  return _internal_node();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouterInfoMessage::set_node(ArgT0&& arg0, ArgT... args) {
 
 node_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.RouterInfoMessage.node)
}
inline std::string* RouterInfoMessage::mutable_node() {
  std::string* _s = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.RouterInfoMessage.node)
  return _s;
}
inline const std::string& RouterInfoMessage::_internal_node() const {
  return node_.Get();
}
inline void RouterInfoMessage::_internal_set_node(const std::string& value) {
  
  node_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RouterInfoMessage::_internal_mutable_node() {
  
  return node_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RouterInfoMessage::release_node() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.RouterInfoMessage.node)
  return node_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RouterInfoMessage::set_allocated_node(std::string* node) {
  if (node != nullptr) {
    
  } else {
    
  }
  node_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (node_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    node_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.RouterInfoMessage.node)
}

// .qaul.net.router_net_info.RoutingInfoTable routes = 2;
inline bool RouterInfoMessage::_internal_has_routes() const {
  return this != internal_default_instance() && routes_ != nullptr;
}
inline bool RouterInfoMessage::has_routes() const {
  return _internal_has_routes();
}
inline void RouterInfoMessage::clear_routes() {
  if (GetArenaForAllocation() == nullptr && routes_ != nullptr) {
    delete routes_;
  }
  routes_ = nullptr;
}
inline const ::qaul::net::router_net_info::RoutingInfoTable& RouterInfoMessage::_internal_routes() const {
  const ::qaul::net::router_net_info::RoutingInfoTable* p = routes_;
  return p != nullptr ? *p : reinterpret_cast<const ::qaul::net::router_net_info::RoutingInfoTable&>(
      ::qaul::net::router_net_info::_RoutingInfoTable_default_instance_);
}
inline const ::qaul::net::router_net_info::RoutingInfoTable& RouterInfoMessage::routes() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RouterInfoMessage.routes)
  return _internal_routes();
}
inline void RouterInfoMessage::unsafe_arena_set_allocated_routes(
    ::qaul::net::router_net_info::RoutingInfoTable* routes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(routes_);
  }
  routes_ = routes;
  if (routes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qaul.net.router_net_info.RouterInfoMessage.routes)
}
inline ::qaul::net::router_net_info::RoutingInfoTable* RouterInfoMessage::release_routes() {
  
  ::qaul::net::router_net_info::RoutingInfoTable* temp = routes_;
  routes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::qaul::net::router_net_info::RoutingInfoTable* RouterInfoMessage::unsafe_arena_release_routes() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.RouterInfoMessage.routes)
  
  ::qaul::net::router_net_info::RoutingInfoTable* temp = routes_;
  routes_ = nullptr;
  return temp;
}
inline ::qaul::net::router_net_info::RoutingInfoTable* RouterInfoMessage::_internal_mutable_routes() {
  
  if (routes_ == nullptr) {
    auto* p = CreateMaybeMessage<::qaul::net::router_net_info::RoutingInfoTable>(GetArenaForAllocation());
    routes_ = p;
  }
  return routes_;
}
inline ::qaul::net::router_net_info::RoutingInfoTable* RouterInfoMessage::mutable_routes() {
  ::qaul::net::router_net_info::RoutingInfoTable* _msg = _internal_mutable_routes();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.RouterInfoMessage.routes)
  return _msg;
}
inline void RouterInfoMessage::set_allocated_routes(::qaul::net::router_net_info::RoutingInfoTable* routes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete routes_;
  }
  if (routes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::qaul::net::router_net_info::RoutingInfoTable>::GetOwningArena(routes);
    if (message_arena != submessage_arena) {
      routes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, routes, submessage_arena);
    }
    
  } else {
    
  }
  routes_ = routes;
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.RouterInfoMessage.routes)
}

// .qaul.net.router_net_info.UserInfoTable users = 3;
inline bool RouterInfoMessage::_internal_has_users() const {
  return this != internal_default_instance() && users_ != nullptr;
}
inline bool RouterInfoMessage::has_users() const {
  return _internal_has_users();
}
inline void RouterInfoMessage::clear_users() {
  if (GetArenaForAllocation() == nullptr && users_ != nullptr) {
    delete users_;
  }
  users_ = nullptr;
}
inline const ::qaul::net::router_net_info::UserInfoTable& RouterInfoMessage::_internal_users() const {
  const ::qaul::net::router_net_info::UserInfoTable* p = users_;
  return p != nullptr ? *p : reinterpret_cast<const ::qaul::net::router_net_info::UserInfoTable&>(
      ::qaul::net::router_net_info::_UserInfoTable_default_instance_);
}
inline const ::qaul::net::router_net_info::UserInfoTable& RouterInfoMessage::users() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RouterInfoMessage.users)
  return _internal_users();
}
inline void RouterInfoMessage::unsafe_arena_set_allocated_users(
    ::qaul::net::router_net_info::UserInfoTable* users) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(users_);
  }
  users_ = users;
  if (users) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qaul.net.router_net_info.RouterInfoMessage.users)
}
inline ::qaul::net::router_net_info::UserInfoTable* RouterInfoMessage::release_users() {
  
  ::qaul::net::router_net_info::UserInfoTable* temp = users_;
  users_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::qaul::net::router_net_info::UserInfoTable* RouterInfoMessage::unsafe_arena_release_users() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.RouterInfoMessage.users)
  
  ::qaul::net::router_net_info::UserInfoTable* temp = users_;
  users_ = nullptr;
  return temp;
}
inline ::qaul::net::router_net_info::UserInfoTable* RouterInfoMessage::_internal_mutable_users() {
  
  if (users_ == nullptr) {
    auto* p = CreateMaybeMessage<::qaul::net::router_net_info::UserInfoTable>(GetArenaForAllocation());
    users_ = p;
  }
  return users_;
}
inline ::qaul::net::router_net_info::UserInfoTable* RouterInfoMessage::mutable_users() {
  ::qaul::net::router_net_info::UserInfoTable* _msg = _internal_mutable_users();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.RouterInfoMessage.users)
  return _msg;
}
inline void RouterInfoMessage::set_allocated_users(::qaul::net::router_net_info::UserInfoTable* users) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete users_;
  }
  if (users) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::qaul::net::router_net_info::UserInfoTable>::GetOwningArena(users);
    if (message_arena != submessage_arena) {
      users = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, users, submessage_arena);
    }
    
  } else {
    
  }
  users_ = users;
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.RouterInfoMessage.users)
}

// uint64 timestamp = 4;
inline void RouterInfoMessage::clear_timestamp() {
  timestamp_ = uint64_t{0u};
}
inline uint64_t RouterInfoMessage::_internal_timestamp() const {
  return timestamp_;
}
inline uint64_t RouterInfoMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RouterInfoMessage.timestamp)
  return _internal_timestamp();
}
inline void RouterInfoMessage::_internal_set_timestamp(uint64_t value) {
  
  timestamp_ = value;
}
inline void RouterInfoMessage::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.RouterInfoMessage.timestamp)
}

// -------------------------------------------------------------------

// Routing

// .qaul.net.router_net_info.UserInfoTable user_info_table = 1;
inline bool Routing::_internal_has_user_info_table() const {
  return message_case() == kUserInfoTable;
}
inline bool Routing::has_user_info_table() const {
  return _internal_has_user_info_table();
}
inline void Routing::set_has_user_info_table() {
  _oneof_case_[0] = kUserInfoTable;
}
inline void Routing::clear_user_info_table() {
  if (_internal_has_user_info_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.user_info_table_;
    }
    clear_has_message();
  }
}
inline ::qaul::net::router_net_info::UserInfoTable* Routing::release_user_info_table() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.Routing.user_info_table)
  if (_internal_has_user_info_table()) {
    clear_has_message();
      ::qaul::net::router_net_info::UserInfoTable* temp = message_.user_info_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.user_info_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qaul::net::router_net_info::UserInfoTable& Routing::_internal_user_info_table() const {
  return _internal_has_user_info_table()
      ? *message_.user_info_table_
      : reinterpret_cast< ::qaul::net::router_net_info::UserInfoTable&>(::qaul::net::router_net_info::_UserInfoTable_default_instance_);
}
inline const ::qaul::net::router_net_info::UserInfoTable& Routing::user_info_table() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.Routing.user_info_table)
  return _internal_user_info_table();
}
inline ::qaul::net::router_net_info::UserInfoTable* Routing::unsafe_arena_release_user_info_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qaul.net.router_net_info.Routing.user_info_table)
  if (_internal_has_user_info_table()) {
    clear_has_message();
    ::qaul::net::router_net_info::UserInfoTable* temp = message_.user_info_table_;
    message_.user_info_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Routing::unsafe_arena_set_allocated_user_info_table(::qaul::net::router_net_info::UserInfoTable* user_info_table) {
  clear_message();
  if (user_info_table) {
    set_has_user_info_table();
    message_.user_info_table_ = user_info_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qaul.net.router_net_info.Routing.user_info_table)
}
inline ::qaul::net::router_net_info::UserInfoTable* Routing::_internal_mutable_user_info_table() {
  if (!_internal_has_user_info_table()) {
    clear_message();
    set_has_user_info_table();
    message_.user_info_table_ = CreateMaybeMessage< ::qaul::net::router_net_info::UserInfoTable >(GetArenaForAllocation());
  }
  return message_.user_info_table_;
}
inline ::qaul::net::router_net_info::UserInfoTable* Routing::mutable_user_info_table() {
  ::qaul::net::router_net_info::UserInfoTable* _msg = _internal_mutable_user_info_table();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.Routing.user_info_table)
  return _msg;
}

// .qaul.net.router_net_info.UserInfo user_info = 2;
inline bool Routing::_internal_has_user_info() const {
  return message_case() == kUserInfo;
}
inline bool Routing::has_user_info() const {
  return _internal_has_user_info();
}
inline void Routing::set_has_user_info() {
  _oneof_case_[0] = kUserInfo;
}
inline void Routing::clear_user_info() {
  if (_internal_has_user_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.user_info_;
    }
    clear_has_message();
  }
}
inline ::qaul::net::router_net_info::UserInfo* Routing::release_user_info() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.Routing.user_info)
  if (_internal_has_user_info()) {
    clear_has_message();
      ::qaul::net::router_net_info::UserInfo* temp = message_.user_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.user_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qaul::net::router_net_info::UserInfo& Routing::_internal_user_info() const {
  return _internal_has_user_info()
      ? *message_.user_info_
      : reinterpret_cast< ::qaul::net::router_net_info::UserInfo&>(::qaul::net::router_net_info::_UserInfo_default_instance_);
}
inline const ::qaul::net::router_net_info::UserInfo& Routing::user_info() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.Routing.user_info)
  return _internal_user_info();
}
inline ::qaul::net::router_net_info::UserInfo* Routing::unsafe_arena_release_user_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qaul.net.router_net_info.Routing.user_info)
  if (_internal_has_user_info()) {
    clear_has_message();
    ::qaul::net::router_net_info::UserInfo* temp = message_.user_info_;
    message_.user_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Routing::unsafe_arena_set_allocated_user_info(::qaul::net::router_net_info::UserInfo* user_info) {
  clear_message();
  if (user_info) {
    set_has_user_info();
    message_.user_info_ = user_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qaul.net.router_net_info.Routing.user_info)
}
inline ::qaul::net::router_net_info::UserInfo* Routing::_internal_mutable_user_info() {
  if (!_internal_has_user_info()) {
    clear_message();
    set_has_user_info();
    message_.user_info_ = CreateMaybeMessage< ::qaul::net::router_net_info::UserInfo >(GetArenaForAllocation());
  }
  return message_.user_info_;
}
inline ::qaul::net::router_net_info::UserInfo* Routing::mutable_user_info() {
  ::qaul::net::router_net_info::UserInfo* _msg = _internal_mutable_user_info();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.Routing.user_info)
  return _msg;
}

// .qaul.net.router_net_info.RoutingInfoTable routing_info_table = 3;
inline bool Routing::_internal_has_routing_info_table() const {
  return message_case() == kRoutingInfoTable;
}
inline bool Routing::has_routing_info_table() const {
  return _internal_has_routing_info_table();
}
inline void Routing::set_has_routing_info_table() {
  _oneof_case_[0] = kRoutingInfoTable;
}
inline void Routing::clear_routing_info_table() {
  if (_internal_has_routing_info_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.routing_info_table_;
    }
    clear_has_message();
  }
}
inline ::qaul::net::router_net_info::RoutingInfoTable* Routing::release_routing_info_table() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.Routing.routing_info_table)
  if (_internal_has_routing_info_table()) {
    clear_has_message();
      ::qaul::net::router_net_info::RoutingInfoTable* temp = message_.routing_info_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.routing_info_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qaul::net::router_net_info::RoutingInfoTable& Routing::_internal_routing_info_table() const {
  return _internal_has_routing_info_table()
      ? *message_.routing_info_table_
      : reinterpret_cast< ::qaul::net::router_net_info::RoutingInfoTable&>(::qaul::net::router_net_info::_RoutingInfoTable_default_instance_);
}
inline const ::qaul::net::router_net_info::RoutingInfoTable& Routing::routing_info_table() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.Routing.routing_info_table)
  return _internal_routing_info_table();
}
inline ::qaul::net::router_net_info::RoutingInfoTable* Routing::unsafe_arena_release_routing_info_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qaul.net.router_net_info.Routing.routing_info_table)
  if (_internal_has_routing_info_table()) {
    clear_has_message();
    ::qaul::net::router_net_info::RoutingInfoTable* temp = message_.routing_info_table_;
    message_.routing_info_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Routing::unsafe_arena_set_allocated_routing_info_table(::qaul::net::router_net_info::RoutingInfoTable* routing_info_table) {
  clear_message();
  if (routing_info_table) {
    set_has_routing_info_table();
    message_.routing_info_table_ = routing_info_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qaul.net.router_net_info.Routing.routing_info_table)
}
inline ::qaul::net::router_net_info::RoutingInfoTable* Routing::_internal_mutable_routing_info_table() {
  if (!_internal_has_routing_info_table()) {
    clear_message();
    set_has_routing_info_table();
    message_.routing_info_table_ = CreateMaybeMessage< ::qaul::net::router_net_info::RoutingInfoTable >(GetArenaForAllocation());
  }
  return message_.routing_info_table_;
}
inline ::qaul::net::router_net_info::RoutingInfoTable* Routing::mutable_routing_info_table() {
  ::qaul::net::router_net_info::RoutingInfoTable* _msg = _internal_mutable_routing_info_table();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.Routing.routing_info_table)
  return _msg;
}

// .qaul.net.router_net_info.RoutingInfoEntry routing_info_entry = 4;
inline bool Routing::_internal_has_routing_info_entry() const {
  return message_case() == kRoutingInfoEntry;
}
inline bool Routing::has_routing_info_entry() const {
  return _internal_has_routing_info_entry();
}
inline void Routing::set_has_routing_info_entry() {
  _oneof_case_[0] = kRoutingInfoEntry;
}
inline void Routing::clear_routing_info_entry() {
  if (_internal_has_routing_info_entry()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.routing_info_entry_;
    }
    clear_has_message();
  }
}
inline ::qaul::net::router_net_info::RoutingInfoEntry* Routing::release_routing_info_entry() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.Routing.routing_info_entry)
  if (_internal_has_routing_info_entry()) {
    clear_has_message();
      ::qaul::net::router_net_info::RoutingInfoEntry* temp = message_.routing_info_entry_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.routing_info_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qaul::net::router_net_info::RoutingInfoEntry& Routing::_internal_routing_info_entry() const {
  return _internal_has_routing_info_entry()
      ? *message_.routing_info_entry_
      : reinterpret_cast< ::qaul::net::router_net_info::RoutingInfoEntry&>(::qaul::net::router_net_info::_RoutingInfoEntry_default_instance_);
}
inline const ::qaul::net::router_net_info::RoutingInfoEntry& Routing::routing_info_entry() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.Routing.routing_info_entry)
  return _internal_routing_info_entry();
}
inline ::qaul::net::router_net_info::RoutingInfoEntry* Routing::unsafe_arena_release_routing_info_entry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qaul.net.router_net_info.Routing.routing_info_entry)
  if (_internal_has_routing_info_entry()) {
    clear_has_message();
    ::qaul::net::router_net_info::RoutingInfoEntry* temp = message_.routing_info_entry_;
    message_.routing_info_entry_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Routing::unsafe_arena_set_allocated_routing_info_entry(::qaul::net::router_net_info::RoutingInfoEntry* routing_info_entry) {
  clear_message();
  if (routing_info_entry) {
    set_has_routing_info_entry();
    message_.routing_info_entry_ = routing_info_entry;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qaul.net.router_net_info.Routing.routing_info_entry)
}
inline ::qaul::net::router_net_info::RoutingInfoEntry* Routing::_internal_mutable_routing_info_entry() {
  if (!_internal_has_routing_info_entry()) {
    clear_message();
    set_has_routing_info_entry();
    message_.routing_info_entry_ = CreateMaybeMessage< ::qaul::net::router_net_info::RoutingInfoEntry >(GetArenaForAllocation());
  }
  return message_.routing_info_entry_;
}
inline ::qaul::net::router_net_info::RoutingInfoEntry* Routing::mutable_routing_info_entry() {
  ::qaul::net::router_net_info::RoutingInfoEntry* _msg = _internal_mutable_routing_info_entry();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.Routing.routing_info_entry)
  return _msg;
}

inline bool Routing::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void Routing::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline Routing::MessageCase Routing::message_case() const {
  return Routing::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RoutingInfoTable

// repeated .qaul.net.router_net_info.RoutingInfoEntry entry = 1;
inline int RoutingInfoTable::_internal_entry_size() const {
  return entry_.size();
}
inline int RoutingInfoTable::entry_size() const {
  return _internal_entry_size();
}
inline void RoutingInfoTable::clear_entry() {
  entry_.Clear();
}
inline ::qaul::net::router_net_info::RoutingInfoEntry* RoutingInfoTable::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.RoutingInfoTable.entry)
  return entry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::RoutingInfoEntry >*
RoutingInfoTable::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:qaul.net.router_net_info.RoutingInfoTable.entry)
  return &entry_;
}
inline const ::qaul::net::router_net_info::RoutingInfoEntry& RoutingInfoTable::_internal_entry(int index) const {
  return entry_.Get(index);
}
inline const ::qaul::net::router_net_info::RoutingInfoEntry& RoutingInfoTable::entry(int index) const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RoutingInfoTable.entry)
  return _internal_entry(index);
}
inline ::qaul::net::router_net_info::RoutingInfoEntry* RoutingInfoTable::_internal_add_entry() {
  return entry_.Add();
}
inline ::qaul::net::router_net_info::RoutingInfoEntry* RoutingInfoTable::add_entry() {
  ::qaul::net::router_net_info::RoutingInfoEntry* _add = _internal_add_entry();
  // @@protoc_insertion_point(field_add:qaul.net.router_net_info.RoutingInfoTable.entry)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::RoutingInfoEntry >&
RoutingInfoTable::entry() const {
  // @@protoc_insertion_point(field_list:qaul.net.router_net_info.RoutingInfoTable.entry)
  return entry_;
}

// -------------------------------------------------------------------

// RoutingInfoEntry

// bytes user = 1;
inline void RoutingInfoEntry::clear_user() {
  user_.ClearToEmpty();
}
inline const std::string& RoutingInfoEntry::user() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RoutingInfoEntry.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoutingInfoEntry::set_user(ArgT0&& arg0, ArgT... args) {
 
 user_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.RoutingInfoEntry.user)
}
inline std::string* RoutingInfoEntry::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.RoutingInfoEntry.user)
  return _s;
}
inline const std::string& RoutingInfoEntry::_internal_user() const {
  return user_.Get();
}
inline void RoutingInfoEntry::_internal_set_user(const std::string& value) {
  
  user_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RoutingInfoEntry::_internal_mutable_user() {
  
  return user_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RoutingInfoEntry::release_user() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.RoutingInfoEntry.user)
  return user_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RoutingInfoEntry::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  user_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.RoutingInfoEntry.user)
}

// uint32 rtt = 2;
inline void RoutingInfoEntry::clear_rtt() {
  rtt_ = 0u;
}
inline uint32_t RoutingInfoEntry::_internal_rtt() const {
  return rtt_;
}
inline uint32_t RoutingInfoEntry::rtt() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RoutingInfoEntry.rtt)
  return _internal_rtt();
}
inline void RoutingInfoEntry::_internal_set_rtt(uint32_t value) {
  
  rtt_ = value;
}
inline void RoutingInfoEntry::set_rtt(uint32_t value) {
  _internal_set_rtt(value);
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.RoutingInfoEntry.rtt)
}

// bytes hc = 3;
inline void RoutingInfoEntry::clear_hc() {
  hc_.ClearToEmpty();
}
inline const std::string& RoutingInfoEntry::hc() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RoutingInfoEntry.hc)
  return _internal_hc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoutingInfoEntry::set_hc(ArgT0&& arg0, ArgT... args) {
 
 hc_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.RoutingInfoEntry.hc)
}
inline std::string* RoutingInfoEntry::mutable_hc() {
  std::string* _s = _internal_mutable_hc();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.RoutingInfoEntry.hc)
  return _s;
}
inline const std::string& RoutingInfoEntry::_internal_hc() const {
  return hc_.Get();
}
inline void RoutingInfoEntry::_internal_set_hc(const std::string& value) {
  
  hc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RoutingInfoEntry::_internal_mutable_hc() {
  
  return hc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RoutingInfoEntry::release_hc() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.RoutingInfoEntry.hc)
  return hc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RoutingInfoEntry::set_allocated_hc(std::string* hc) {
  if (hc != nullptr) {
    
  } else {
    
  }
  hc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hc,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hc_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.RoutingInfoEntry.hc)
}

// float pl = 4;
inline void RoutingInfoEntry::clear_pl() {
  pl_ = 0;
}
inline float RoutingInfoEntry::_internal_pl() const {
  return pl_;
}
inline float RoutingInfoEntry::pl() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.RoutingInfoEntry.pl)
  return _internal_pl();
}
inline void RoutingInfoEntry::_internal_set_pl(float value) {
  
  pl_ = value;
}
inline void RoutingInfoEntry::set_pl(float value) {
  _internal_set_pl(value);
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.RoutingInfoEntry.pl)
}

// -------------------------------------------------------------------

// UserInfoTable

// repeated .qaul.net.router_net_info.UserInfo info = 1;
inline int UserInfoTable::_internal_info_size() const {
  return info_.size();
}
inline int UserInfoTable::info_size() const {
  return _internal_info_size();
}
inline void UserInfoTable::clear_info() {
  info_.Clear();
}
inline ::qaul::net::router_net_info::UserInfo* UserInfoTable::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.UserInfoTable.info)
  return info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::UserInfo >*
UserInfoTable::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:qaul.net.router_net_info.UserInfoTable.info)
  return &info_;
}
inline const ::qaul::net::router_net_info::UserInfo& UserInfoTable::_internal_info(int index) const {
  return info_.Get(index);
}
inline const ::qaul::net::router_net_info::UserInfo& UserInfoTable::info(int index) const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.UserInfoTable.info)
  return _internal_info(index);
}
inline ::qaul::net::router_net_info::UserInfo* UserInfoTable::_internal_add_info() {
  return info_.Add();
}
inline ::qaul::net::router_net_info::UserInfo* UserInfoTable::add_info() {
  ::qaul::net::router_net_info::UserInfo* _add = _internal_add_info();
  // @@protoc_insertion_point(field_add:qaul.net.router_net_info.UserInfoTable.info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::net::router_net_info::UserInfo >&
UserInfoTable::info() const {
  // @@protoc_insertion_point(field_list:qaul.net.router_net_info.UserInfoTable.info)
  return info_;
}

// -------------------------------------------------------------------

// UserInfo

// bytes id = 1;
inline void UserInfo::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& UserInfo::id() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.UserInfo.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.UserInfo.id)
}
inline std::string* UserInfo::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.UserInfo.id)
  return _s;
}
inline const std::string& UserInfo::_internal_id() const {
  return id_.Get();
}
inline void UserInfo::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_id() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.UserInfo.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserInfo::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.UserInfo.id)
}

// bytes key = 2;
inline void UserInfo::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& UserInfo::key() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.UserInfo.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.UserInfo.key)
}
inline std::string* UserInfo::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.UserInfo.key)
  return _s;
}
inline const std::string& UserInfo::_internal_key() const {
  return key_.Get();
}
inline void UserInfo::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_key() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.UserInfo.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserInfo::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.UserInfo.key)
}

// string name = 3;
inline void UserInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& UserInfo::name() const {
  // @@protoc_insertion_point(field_get:qaul.net.router_net_info.UserInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.net.router_net_info.UserInfo.name)
}
inline std::string* UserInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:qaul.net.router_net_info.UserInfo.name)
  return _s;
}
inline const std::string& UserInfo::_internal_name() const {
  return name_.Get();
}
inline void UserInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_name() {
  // @@protoc_insertion_point(field_release:qaul.net.router_net_info.UserInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.net.router_net_info.UserInfo.name)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace router_net_info
}  // namespace net
}  // namespace qaul

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_router_2frouter_5fnet_5finfo_2eproto
